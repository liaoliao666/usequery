{"version":3,"file":"vue-query.production.min.js","sources":["../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","../node_modules/@babel/runtime/helpers/esm/extends.js","../src/core/utils.ts","../src/core/logger.ts","../src/core/subscribable.ts","../src/core/focusManager.ts","../src/core/onlineManager.ts","../src/core/retryer.ts","../src/core/query.ts","../src/core/queryCache.ts","../src/core/mutation.ts","../src/core/mutationCache.ts","../src/core/infiniteQueryBehavior.ts","../src/core/queryClient.ts","../src/core/queryObserver.ts","../src/core/queriesObserver.ts","../src/core/infiniteQueryObserver.ts","../src/core/mutationObserver.ts","../src/use/logger.ts","../src/use/setLogger.ts","../src/use/QueryClientProvider.ts","../src/use/useBaseQuery.ts","../src/use/useInfiniteQuery.ts","../src/use/useIsFetching.ts","../src/use/useMutation.ts","../src/use/useQueries.ts","../src/use/useQuery.ts"],"sourcesContent":["export default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}","export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","import { isRef } from 'vue'\n\nimport type { Query } from './query'\nimport type {\n  MutationFunction,\n  MutationKeyWithRef,\n  MutationOptions,\n  MutationOptionsWithRef,\n  QueryFunction,\n  QueryKey,\n  QueryKeyHashFunction,\n  QueryKeyWithRef,\n  QueryOptions,\n  QueryOptionsWithRef,\n  QueryStatus,\n} from './types'\n\n// TYPES\n\nexport interface QueryFilters {\n  /**\n   * Include or exclude active queries\n   */\n  active?: boolean\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include or exclude inactive queries\n   */\n  inactive?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: QueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include or exclude fetching queries\n   */\n  fetching?: boolean\n}\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined'\n\nexport function noop(): undefined {\n  return undefined\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: any): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function ensureArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value]\n}\n\nexport function difference<T>(array1: T[], array2: T[]): T[] {\n  return array1.filter(x => array2.indexOf(x) === -1)\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function parseQueryArgs<TOptions extends QueryOptions<any, any, any>>(\n  arg1: QueryKeyWithRef | QueryOptionsWithRef<any, any, any>,\n  arg2?: QueryFunction<any> | QueryOptionsWithRef<any, any, any>,\n  arg3?: QueryOptionsWithRef<any, any, any>\n): TOptions {\n  if (!isQueryKey(arg1)) {\n    return arg1 as TOptions\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3, queryKey: arg1, queryFn: arg2 } as TOptions\n  }\n\n  return unwrapRefs({ ...arg2, queryKey: arg1 }) as TOptions\n}\n\nexport function parseMutationArgs<\n  TOptions extends MutationOptions<any, any, any, any>\n>(\n  arg1:\n    | MutationKeyWithRef\n    | MutationFunction<any, any>\n    | MutationOptionsWithRef<any, any, any, any>,\n  arg2?:\n    | MutationFunction<any, any>\n    | MutationOptionsWithRef<any, any, any, any>,\n  arg3?: MutationOptionsWithRef<any, any, any, any>\n): TOptions {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return unwrapRefs({\n        ...arg3,\n        mutationKey: arg1,\n        mutationFn: arg2,\n      }) as TOptions\n    }\n    return unwrapRefs({ ...arg2, mutationKey: arg1 }) as TOptions\n  }\n\n  if (typeof arg1 === 'function') {\n    return unwrapRefs({ ...arg2, mutationFn: arg1 }) as TOptions\n  }\n\n  return unwrapRefs({ ...arg1 }) as TOptions\n}\n\nexport function parseFilterArgs<\n  TFilters extends QueryFilters,\n  TOptions = unknown\n>(\n  arg1?: QueryKeyWithRef | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions\n): [TFilters, TOptions | undefined] {\n  return (isQueryKey(arg1)\n    ? [{ ...arg2, queryKey: unwrapRefs(arg1) }, arg3]\n    : [arg1 || {}, arg2]) as [TFilters, TOptions]\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any>\n): boolean {\n  const {\n    active,\n    exact,\n    fetching,\n    inactive,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      const hashFn = getQueryKeyHashFn(query.options)\n      if (query.queryHash !== hashFn(queryKey)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  let isActive\n\n  if (inactive === false || (active && !inactive)) {\n    isActive = true\n  } else if (active === false || (inactive && !active)) {\n    isActive = false\n  }\n\n  if (typeof isActive === 'boolean' && query.isActive() !== isActive) {\n    return false\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (typeof fetching === 'boolean' && query.isFetching() !== fetching) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function getQueryKeyHashFn(\n  options?: QueryOptions<any, any>\n): QueryKeyHashFunction {\n  return options?.queryKeyHashFn || hashQueryKey\n}\n\n/**\n * Default query keys hash function.\n */\nexport function hashQueryKey(queryKey: QueryKey): string {\n  return stableValueHash(queryKey)\n}\n\n/**\n * Hashes the value into a stable hash.\n */\nexport function stableValueHash(value: any): string {\n  return JSON.stringify(value, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(\n  a: string | unknown[],\n  b: string | unknown[]\n): boolean {\n  return partialDeepEqual(ensureArray(a), ensureArray(b))\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any) {\n  if (a === b) return a\n\n  const array = Array.isArray(a) && Array.isArray(b)\n  const isSameObject = array || (isPlainObject(a) && isPlainObject(b))\n\n  if (isSameObject) {\n    if (array) {\n      const bSize = b.length\n      // omit array keys\n      if (a.length > bSize) {\n        a.splice(bSize)\n      }\n\n      // pick array keys\n      for (let i = 0; i < bSize; i++) {\n        a[i] = replaceEqualDeep(a[i], b[i])\n      }\n    } else {\n      const aKeys = Object.keys(a)\n      const bKeys = Object.keys(b)\n      const hash = new Set(bKeys)\n\n      for (let i = 0, len = aKeys.length; i < len; i++) {\n        const key = aKeys[i]\n        if (!hash.has(key)) {\n          // omit object keys\n          delete a[key]\n        }\n      }\n\n      for (let i = 0, len = bKeys.length; i < len; i++) {\n        const key = bKeys[i]\n        // pick object keys\n        a[key] = replaceEqualDeep(a[key], b[key])\n      }\n    }\n  }\n\n  return isSameObject ? a : b\n}\n\n/**\n * it will replace any equal shallow children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceShallowEqualDeep<T>(a: unknown, b: T): T\nexport function replaceShallowEqualDeep(a: any, b: any) {\n  if (a === b) return a\n\n  const array = Array.isArray(a) && Array.isArray(b)\n  const isSameObject = array || (isPlainObject(a) && isPlainObject(b))\n\n  if (isSameObject) {\n    if (array) {\n      const bSize = b.length\n      // omit array keys\n      if (a.length > bSize) {\n        a.splice(bSize)\n      }\n\n      // pick array keys\n      for (let i = 0; i < bSize; i++) {\n        a[i] = b[i]\n      }\n    } else {\n      const aKeys = Object.keys(a)\n      const bKeys = Object.keys(b)\n      const hash = new Set(bKeys)\n\n      for (let i = 0, len = aKeys.length; i < len; i++) {\n        const key = aKeys[i]\n        if (!hash.has(key)) {\n          // omit object keys\n          delete a[key]\n        }\n      }\n\n      for (let i = 0, len = bKeys.length; i < len; i++) {\n        const key = bKeys[i]\n        // pick object keys\n        a[key] = b[key]\n      }\n    }\n  }\n\n  return isSameObject ? a : b\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function isQueryKey(value: any): value is QueryKey {\n  return typeof value === 'string' || Array.isArray(value)\n}\n\nexport function isError(value: any): value is Error {\n  return value instanceof Error\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout)\n  })\n}\n\nexport function getStatusProps<T extends QueryStatus>(status: T) {\n  return {\n    status,\n    isLoading: status === 'loading',\n    isSuccess: status === 'success',\n    isError: status === 'error',\n    isIdle: status === 'idle',\n  }\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nexport function scheduleMicrotask(callback: () => void): void {\n  Promise.resolve()\n    .then(callback)\n    .catch(error =>\n      setTimeout(() => {\n        throw error\n      })\n    )\n}\n\n/**\n * it will deeply unwrap the value of ref from ref\n */\nexport function unwrapRefs(refs: any) {\n  if (isRef(refs)) {\n    return refs.value\n  }\n\n  if (typeof refs === 'function') return refs\n\n  const array = Array.isArray(refs)\n\n  if (array || isPlainObject(refs)) {\n    const items = array ? refs : Object.keys(refs)\n    const size = items.length\n    const copy: any = array ? [] : {}\n\n    for (let i = 0; i < size; i++) {\n      const key = array ? i : items[i]\n\n      copy[key] = isRef(refs[key]) ? refs[key].value : unwrapRefs(refs[key])\n    }\n    return copy\n  }\n\n  return refs\n}\n","import { noop } from './utils'\n\n// TYPES\n\nexport interface Logger {\n  log: LogFunction\n  warn: LogFunction\n  error: LogFunction\n}\n\ntype LogFunction = (...args: any[]) => void\n\n// FUNCTIONS\n\nlet logger: Logger = console || {\n  error: noop,\n  warn: noop,\n  log: noop,\n}\n\nexport function getLogger(): Logger {\n  return logger\n}\n\nexport function setLogger(newLogger: Logger) {\n  logger = newLogger\n}\n","type Listener = () => void\n\nexport class Subscribable<TListener extends Function = Listener> {\n  protected listeners: TListener[]\n\n  constructor() {\n    this.listeners = []\n  }\n\n  subscribe(listener?: TListener): () => void {\n    const callback = listener || (() => undefined)\n\n    this.listeners.push(callback as TListener)\n\n    this.onSubscribe()\n\n    return () => {\n      this.listeners = this.listeners.filter(x => x !== callback)\n      this.onUnsubscribe()\n    }\n  }\n\n  hasListeners(): boolean {\n    return this.listeners.length > 0\n  }\n\n  protected onSubscribe(): void {\n    // Do nothing\n  }\n\n  protected onUnsubscribe(): void {\n    // Do nothing\n  }\n}\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\nclass FocusManager extends Subscribable {\n  private focused?: boolean\n  private removeEventListener?: () => void\n\n  protected onSubscribe(): void {\n    if (!this.removeEventListener) {\n      this.setDefaultEventListener()\n    }\n  }\n\n  setEventListener(\n    setup: (onFocus: () => void) => (focused?: boolean) => void\n  ): void {\n    if (this.removeEventListener) {\n      this.removeEventListener()\n    }\n    this.removeEventListener = setup((focused?: boolean) => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused)\n      } else {\n        this.onFocus()\n      }\n    })\n  }\n\n  setFocused(focused?: boolean): void {\n    this.focused = focused\n\n    if (focused) {\n      this.onFocus()\n    }\n  }\n\n  onFocus(): void {\n    this.listeners.forEach(listener => {\n      listener()\n    })\n  }\n\n  isFocused(): boolean {\n    if (typeof this.focused === 'boolean') {\n      return this.focused\n    }\n\n    // document global can be unavailable in react native\n    if (typeof document === 'undefined') {\n      return true\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(\n      document.visibilityState\n    )\n  }\n\n  private setDefaultEventListener() {\n    if (!isServer && window?.addEventListener) {\n      this.setEventListener(onFocus => {\n        // Listen to visibillitychange and focus\n        window.addEventListener('visibilitychange', onFocus, false)\n        window.addEventListener('focus', onFocus, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', onFocus)\n          window.removeEventListener('focus', onFocus)\n        }\n      })\n    }\n  }\n}\n\nexport const focusManager = new FocusManager()\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\nclass OnlineManager extends Subscribable {\n  private online?: boolean\n  private removeEventListener?: () => void\n\n  protected onSubscribe(): void {\n    if (!this.removeEventListener) {\n      this.setDefaultEventListener()\n    }\n  }\n\n  setEventListener(\n    setup: (setOnline: () => void) => (online?: boolean) => void\n  ): void {\n    if (this.removeEventListener) {\n      this.removeEventListener()\n    }\n    this.removeEventListener = setup((online?: boolean) => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online)\n      } else {\n        this.onOnline()\n      }\n    })\n  }\n\n  setOnline(online?: boolean): void {\n    this.online = online\n\n    if (online) {\n      this.onOnline()\n    }\n  }\n\n  onOnline(): void {\n    this.listeners.forEach(listener => {\n      listener()\n    })\n  }\n\n  isOnline(): boolean {\n    if (typeof this.online === 'boolean') {\n      return this.online\n    }\n\n    return navigator.onLine === undefined || navigator.onLine\n  }\n\n  private setDefaultEventListener() {\n    if (!isServer && window?.addEventListener) {\n      this.setEventListener(onOnline => {\n        // Listen to online\n        window.addEventListener('online', onOnline, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', onOnline)\n        }\n      })\n    }\n  }\n}\n\nexport const onlineManager = new OnlineManager()\n","import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { functionalUpdate, sleep } from './utils'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = unknown> {\n  fn: () => TData | Promise<TData>\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError = unknown> = (\n  failureCount: number,\n  error: TError\n) => boolean\n\nexport type RetryDelayValue = number | RetryDelayFunction\n\ntype RetryDelayFunction = (failureCount: number) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\ninterface Cancelable {\n  cancel(): void\n}\n\nexport function isCancelable(value: any): value is Cancelable {\n  return typeof value?.cancel === 'function'\n}\n\nexport interface CancelOptions {\n  revert?: boolean\n  silent?: boolean\n}\n\nexport class CancelledError {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\n// CLASS\n\nexport class Retryer<TData = unknown, TError = unknown> {\n  cancel: (options?: CancelOptions) => void\n  cancelRetry: () => void\n  continue: () => void\n  failureCount: number\n  isPaused: boolean\n  isResolved: boolean\n  isTransportCancelable: boolean\n  promise: Promise<TData>\n\n  constructor(config: RetryerConfig<TData, TError>) {\n    let cancelRetry = false\n    let cancelFn: ((options?: CancelOptions) => void) | undefined\n    let continueFn: ((value?: unknown) => void) | undefined\n    let promiseResolve: (data: TData) => void\n    let promiseReject: (error: TError) => void\n\n    this.cancel = cancelOptions => cancelFn?.(cancelOptions)\n    this.cancelRetry = () => {\n      cancelRetry = true\n    }\n    this.continue = () => continueFn?.()\n    this.failureCount = 0\n    this.isPaused = false\n    this.isResolved = false\n    this.isTransportCancelable = false\n    this.promise = new Promise<TData>((outerResolve, outerReject) => {\n      promiseResolve = outerResolve\n      promiseReject = outerReject\n    })\n\n    const resolve = (value: any) => {\n      this.isResolved = true\n      continueFn?.()\n      promiseResolve(value)\n    }\n\n    const reject = (value: any) => {\n      this.isResolved = true\n      continueFn?.()\n      promiseReject(value)\n    }\n\n    const pause = () => {\n      return new Promise(continueResolve => {\n        continueFn = continueResolve\n        this.isPaused = true\n        config.onPause?.()\n      }).then(() => {\n        continueFn = undefined\n        this.isPaused = false\n        config.onContinue?.()\n      })\n    }\n\n    // Create loop function\n    const run = () => {\n      // Do nothing if already resolved\n      if (this.isResolved) {\n        return\n      }\n\n      let promiseOrValue: any\n\n      // Execute query\n      try {\n        promiseOrValue = config.fn()\n      } catch (error) {\n        promiseOrValue = Promise.reject(error)\n      }\n\n      // Create callback to cancel this fetch\n      cancelFn = cancelOptions => {\n        reject(new CancelledError(cancelOptions))\n\n        // Cancel transport if supported\n        if (isCancelable(promiseOrValue)) {\n          try {\n            promiseOrValue.cancel()\n          } catch {}\n        }\n      }\n\n      // Check if the transport layer support cancellation\n      this.isTransportCancelable = isCancelable(promiseOrValue)\n\n      Promise.resolve(promiseOrValue)\n        .then(resolve)\n        .catch(error => {\n          // Stop if the fetch is already resolved\n          if (this.isResolved) {\n            return\n          }\n\n          // Do we need to retry the request?\n          const retry = config.retry ?? 3\n          const retryDelay = config.retryDelay ?? defaultRetryDelay\n          const delay = functionalUpdate(retryDelay, this.failureCount) || 0\n          const shouldRetry =\n            retry === true ||\n            (typeof retry === 'number' && this.failureCount < retry) ||\n            (typeof retry === 'function' && retry(this.failureCount, error))\n\n          if (cancelRetry || !shouldRetry) {\n            // We are done if the query does not need to be retried\n            reject(error)\n            return\n          }\n\n          this.failureCount++\n\n          // Notify on fail\n          config.onFail?.(this.failureCount, error)\n\n          // Delay\n          sleep(delay)\n            // Pause if the document is not visible or when the device is offline\n            .then(() => {\n              if (!focusManager.isFocused() || !onlineManager.isOnline()) {\n                return pause()\n              }\n            })\n            .then(() => {\n              if (cancelRetry) {\n                reject(error)\n              } else {\n                run()\n              }\n            })\n        })\n    }\n\n    // Start loop\n    run()\n  }\n}\n","import { reactive, readonly } from 'vue'\n\nimport {\n  Updater,\n  ensureArray,\n  functionalUpdate,\n  isValidTimeout,\n  noop,\n  replaceEqualDeep,\n  timeUntilStale,\n} from './utils'\nimport type {\n  InitialDataFunction,\n  QueryKey,\n  QueryOptions,\n  QueryStatus,\n  QueryFunctionContext,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport type { QueryObserver } from './queryObserver'\nimport { getLogger } from './logger'\nimport { Retryer, CancelOptions, isCancelledError } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<TQueryFnData, TError, TData> {\n  cache: QueryCache\n  queryKey: QueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = unknown> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchMeta: any\n  isFetching: boolean\n  isInvalidated: boolean\n  isPaused: boolean\n  status: QueryStatus\n}\n\nexport interface FetchContext<TQueryFnData, TError, TData> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  options: QueryOptions<TQueryFnData, TError, TData>\n  queryKey: QueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n> {\n  onFetch: (context: FetchContext<TQueryFnData, TError, TData>) => void\n}\n\nexport interface FetchOptions {\n  cancelRefetch?: boolean\n  meta?: any\n}\n\nexport interface SetDataOptions {\n  updatedAt?: number\n}\n\ninterface FailedAction {\n  type: 'failed'\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: any\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: QueryState<TData, TError>\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n> {\n  queryKey: QueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData>\n  initialState: QueryState<TData, TError>\n  state: QueryState<TData, TError>\n  cacheTime!: number\n\n  private innerState: QueryState<TData, TError>\n  private cache: QueryCache\n  private promise?: Promise<TData>\n  private gcTimeout?: number\n  private retryer?: Retryer<unknown, TError>\n  private observers: QueryObserver<any, any, any, any>[]\n  private defaultOptions?: QueryOptions<TQueryFnData, TError, TData>\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData>) {\n    this.defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.cache = config.cache\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.initialState = config.state || this.getDefaultState(this.options)\n    this.innerState = reactive(this.initialState) as QueryState<TData, TError>\n    this.state = readonly(this.innerState) as QueryState<TData, TError>\n    this.scheduleGc()\n  }\n\n  private setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData>\n  ): void {\n    this.options = { ...this.defaultOptions, ...options }\n\n    // Default to 5 minutes if not cache time is set\n    this.cacheTime = Math.max(\n      this.cacheTime || 0,\n      this.options.cacheTime ?? 5 * 60 * 1000\n    )\n  }\n\n  setDefaultOptions(options: QueryOptions<TQueryFnData, TError, TData>): void {\n    this.defaultOptions = options\n  }\n\n  private scheduleGc(): void {\n    this.clearGcTimeout()\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove()\n      }, this.cacheTime)\n    }\n  }\n\n  private clearGcTimeout() {\n    clearTimeout(this.gcTimeout)\n    this.gcTimeout = undefined\n  }\n\n  private optionalRemove() {\n    if (!this.observers.length && !this.state.isFetching) {\n      this.cache.remove(this)\n    }\n  }\n\n  setData(\n    updater: Updater<TData | undefined, TData>,\n    options?: SetDataOptions\n  ): TData {\n    const prevData = this.innerState.data\n\n    // Get the new data\n    let data = functionalUpdate(updater, prevData)\n\n    // Use prev data if an isDataEqual function is defined and returns `true`\n    if (this.options.isDataEqual?.(prevData, data)) {\n      data = prevData as TData\n    } else if (this.options.structuralSharing !== false) {\n      // Structurally share data between prev and new data if needed\n      data = replaceEqualDeep(prevData, data)\n    }\n\n    // Set data and mark it as cached\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n    })\n\n    return data\n  }\n\n  setState(state: QueryState<TData, TError>): void {\n    this.dispatch({ type: 'setState', state })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.promise\n    this.retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    this.clearGcTimeout()\n    this.cancel()\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some(observer => observer.options.enabled !== false)\n  }\n\n  isFetching(): boolean {\n    return this.state.isFetching\n  }\n\n  isStale(): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      this.observers.some(observer => observer.getReadonlyResult().isStale)\n    )\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n    )\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find(x => x.willFetchOnWindowFocus())\n\n    if (observer) {\n      observer.refetch()\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find(x => x.willFetchOnReconnect())\n\n    if (observer) {\n      observer.refetch()\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any>): void {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.cache.notify(this)\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any>): void {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter(x => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.retryer.isTransportCancelable) {\n            this.retryer.cancel()\n          } else {\n            this.retryer.cancelRetry()\n          }\n        }\n\n        if (this.cacheTime) {\n          this.scheduleGc()\n        } else {\n          this.cache.remove(this)\n        }\n      }\n\n      this.cache.notify(this)\n    }\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData>,\n    fetchOptions?: FetchOptions\n  ): Promise<TData> {\n    if (this.state.isFetching)\n      if (this.state.dataUpdatedAt && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({ silent: true })\n      } else if (this.promise) {\n        // Return current promise if we are already fetching\n        return this.promise\n      }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    // Create query function context\n    const queryKey = ensureArray(this.queryKey)\n    const queryFnContext: QueryFunctionContext = {\n      queryKey,\n      pageParam: undefined,\n    }\n\n    // Create fetch function\n    const fetchFn = () =>\n      this.options.queryFn\n        ? this.options.queryFn(queryFnContext)\n        : Promise.reject('Missing queryFn')\n\n    // Trigger behavior hook\n    const context: FetchContext<TQueryFnData, TError, TData> = {\n      fetchOptions,\n      options: this.options,\n      queryKey,\n      state: this.state,\n      fetchFn,\n    }\n\n    if (this.options.behavior?.onFetch) {\n      this.options.behavior?.onFetch(context)\n    }\n\n    // Set to fetching state if not already in it\n    if (\n      !this.state.isFetching ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    // Try to fetch the data\n    this.retryer = new Retryer({\n      fn: context.fetchFn,\n      onFail: () => {\n        this.dispatch({ type: 'failed' })\n      },\n      onPause: () => {\n        this.dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n    })\n\n    this.promise = this.retryer.promise\n      .then(data => this.setData(data as TData))\n      .catch(error => {\n        // Set error state if needed\n        if (!(isCancelledError(error) && error.silent)) {\n          this.dispatch({\n            type: 'error',\n            error,\n          })\n        }\n\n        // Log error\n        if (!isCancelledError(error)) {\n          getLogger().error(error)\n        }\n\n        // Propagate error\n        throw error\n      })\n      .finally(() => {\n        // Remove query after fetching if cache time is 0\n        if (this.cacheTime === 0) {\n          this.optionalRemove()\n        }\n      })\n\n    return this.promise\n  }\n\n  private dispatch(action: Action<TData, TError>): void {\n    Object.assign(this.innerState, this.reducer(this.state, action))\n\n    this.observers.forEach(observer => {\n      observer.onQueryUpdate(action)\n    })\n\n    this.cache.notify(this)\n  }\n\n  protected getDefaultState(\n    options: QueryOptions<TQueryFnData, TError, TData>\n  ): QueryState<TData, TError> {\n    const data =\n      typeof options.initialData === 'function'\n        ? (options.initialData as InitialDataFunction<TData>)()\n        : options.initialData\n\n    const hasData = typeof data !== 'undefined'\n\n    return {\n      data,\n      dataUpdateCount: 0,\n      dataUpdatedAt: hasData ? Date.now() : 0,\n      error: null,\n      errorUpdateCount: 0,\n      errorUpdatedAt: 0,\n      fetchFailureCount: 0,\n      fetchMeta: null,\n      isFetching: false,\n      isInvalidated: false,\n      isPaused: false,\n      status: hasData ? 'success' : 'idle',\n    }\n  }\n\n  protected reducer(\n    state: QueryState<TData, TError>,\n    action: Action<TData, TError>\n  ): QueryState<TData, TError> {\n    switch (action.type) {\n      case 'failed':\n        return {\n          ...state,\n          fetchFailureCount: state.fetchFailureCount + 1,\n        }\n      case 'pause':\n        return {\n          ...state,\n          isPaused: true,\n        }\n      case 'continue':\n        return {\n          ...state,\n          isPaused: false,\n        }\n      case 'fetch':\n        return {\n          ...state,\n          fetchFailureCount: 0,\n          fetchMeta: action.meta ?? null,\n          isFetching: true,\n          isPaused: false,\n          status: state.status === 'idle' ? 'loading' : state.status,\n        }\n      case 'success':\n        return {\n          ...state,\n          data: action.data,\n          dataUpdateCount: state.dataUpdateCount + 1,\n          dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n          error: null,\n          fetchFailureCount: 0,\n          isFetching: false,\n          isInvalidated: false,\n          isPaused: false,\n          status: 'success',\n        }\n      case 'error':\n        const error = action.error as unknown\n\n        if (isCancelledError(error) && error.revert) {\n          return {\n            ...state,\n            fetchFailureCount: 0,\n            isFetching: false,\n            isPaused: false,\n            status: state.status === 'loading' ? 'idle' : state.status,\n          }\n        }\n\n        return {\n          ...state,\n          error: error as TError,\n          errorUpdateCount: state.errorUpdateCount + 1,\n          errorUpdatedAt: Date.now(),\n          fetchFailureCount: state.fetchFailureCount + 1,\n          isFetching: false,\n          isPaused: false,\n          status: 'error',\n        }\n      case 'invalidate':\n        return {\n          ...state,\n          isInvalidated: true,\n        }\n      case 'setState':\n        return {\n          ...state,\n          ...action.state,\n        }\n      default:\n        return state\n    }\n  }\n}\n","import {\n  QueryFilters,\n  getQueryKeyHashFn,\n  matchQuery,\n  parseFilterArgs,\n} from './utils'\nimport { Query, QueryState } from './query'\nimport type { QueryKeyWithRef, QueryOptions } from './types'\nimport type { QueryClient } from './queryClient'\nimport { Subscribable } from './subscribable'\n\n// TYPES\n\ninterface QueryHashMap {\n  [hash: string]: Query<any, any>\n}\n\ntype QueryCacheListener = (query?: Query) => void\n\n// CLASS\n\nexport class QueryCache extends Subscribable<QueryCacheListener> {\n  private queries: Query<any, any>[]\n  private queriesMap: QueryHashMap\n\n  constructor() {\n    super()\n\n    this.queries = []\n    this.queriesMap = {}\n  }\n\n  build<TQueryFnData, TError, TData>(\n    client: QueryClient,\n    options: QueryOptions<TQueryFnData, TError, TData>,\n    state?: QueryState<TData, TError>\n  ): Query<TQueryFnData, TError, TData> {\n    const hashFn = getQueryKeyHashFn(options)\n    const queryKey = options.queryKey!\n    const queryHash = options.queryHash ?? hashFn(queryKey)\n    let query = this.get<TQueryFnData, TError, TData>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n\n  add(query: Query<any, any>): void {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query\n      this.queries.push(query)\n      this.notify(query)\n    }\n  }\n\n  remove(query: Query<any, any>): void {\n    const queryInMap = this.queriesMap[query.queryHash]\n\n    if (queryInMap) {\n      query.destroy()\n\n      this.queries = this.queries.filter(x => x !== query)\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash]\n      }\n\n      this.notify(query)\n    }\n  }\n\n  clear(): void {\n    this.queries.forEach(query => {\n      this.remove(query)\n    })\n  }\n\n  get<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    queryHash: string\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    return this.queriesMap[queryHash]\n  }\n\n  getAll(): Query[] {\n    return this.queries\n  }\n\n  find<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    arg1: QueryKeyWithRef,\n    arg2?: QueryFilters\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    return this.queries.find(query => matchQuery(filters, query))\n  }\n\n  findAll(queryKey?: QueryKeyWithRef, filters?: QueryFilters): Query[]\n  findAll(filters?: QueryFilters): Query[]\n  findAll(arg1?: QueryKeyWithRef | QueryFilters, arg2?: QueryFilters): Query[]\n  findAll(arg1?: QueryKeyWithRef | QueryFilters, arg2?: QueryFilters): Query[] {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    return filters\n      ? this.queries.filter(query => matchQuery(filters, query))\n      : this.queries\n  }\n\n  notify(query?: Query<any, any>) {\n    this.listeners.forEach(listener => {\n      listener(query)\n    })\n  }\n\n  onFocus(): void {\n    this.queries.forEach(query => {\n      query.onFocus()\n    })\n  }\n\n  onOnline(): void {\n    this.queries.forEach(query => {\n      query.onOnline()\n    })\n  }\n}\n","import type { MutationOptions, MutationStatus } from './types'\nimport type { MutationCache } from './mutationCache'\nimport type { MutationObserver } from './mutationObserver'\nimport { getLogger } from './logger'\nimport { Retryer } from './retryer'\nimport { noop } from './utils'\n\n// TYPES\n\ninterface MutationConfig<TData, TError, TVariables, TContext> {\n  mutationId: number\n  mutationCache: MutationCache\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  defaultOptions?: MutationOptions<TData, TError, TVariables, TContext>\n  state?: MutationState<TData, TError, TVariables, TContext>\n}\n\nexport interface MutationState<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n> {\n  context: TContext | undefined\n  data: TData | undefined\n  error: TError | null\n  failureCount: number\n  isPaused: boolean\n  status: MutationStatus\n  variables: TVariables | undefined\n}\n\ninterface FailedAction {\n  type: 'failed'\n}\n\ninterface LoadingAction<TVariables, TContext> {\n  type: 'loading'\n  variables?: TVariables\n  context?: TContext\n}\n\ninterface SuccessAction<TData> {\n  type: 'success'\n  data: TData\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError, TVariables, TContext> {\n  type: 'setState'\n  state: MutationState<TData, TError, TVariables, TContext>\n}\n\nexport type Action<TData, TError, TVariables, TContext> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction\n  | LoadingAction<TVariables, TContext>\n  | PauseAction\n  | SetStateAction<TData, TError, TVariables, TContext>\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Mutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n> {\n  state: MutationState<TData, TError, TVariables, TContext>\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  mutationId: number\n\n  private observers: MutationObserver<TData, TError, TVariables, TContext>[]\n  private mutationCache: MutationCache\n  private retryer?: Retryer<TData, TError>\n\n  constructor(config: MutationConfig<TData, TError, TVariables, TContext>) {\n    this.options = {\n      ...config.defaultOptions,\n      ...config.options,\n    }\n    this.mutationId = config.mutationId\n    this.mutationCache = config.mutationCache\n    this.observers = []\n    this.state = config.state || getDefaultState()\n  }\n\n  setState(state: MutationState<TData, TError, TVariables, TContext>): void {\n    this.dispatch({ type: 'setState', state })\n  }\n\n  addObserver(observer: MutationObserver<any, any, any, any>): void {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer)\n    }\n  }\n\n  removeObserver(observer: MutationObserver<any, any, any, any>): void {\n    this.observers = this.observers.filter(x => x !== observer)\n  }\n\n  cancel(): Promise<void> {\n    if (this.retryer) {\n      this.retryer.cancel()\n      return this.retryer.promise.then(noop).catch(noop)\n    }\n    return Promise.resolve()\n  }\n\n  continue(): Promise<TData> {\n    if (this.retryer) {\n      this.retryer.continue()\n      return this.retryer.promise\n    }\n    return this.execute()\n  }\n\n  execute(): Promise<TData> {\n    let data: TData\n\n    const restored = this.state.status === 'loading'\n\n    let promise = Promise.resolve()\n\n    if (!restored) {\n      this.dispatch({ type: 'loading', variables: this.options.variables! })\n      promise = promise\n        .then(() => this.options.onMutate?.(this.state.variables!))\n        .then(context => {\n          if (context !== this.state.context) {\n            this.dispatch({\n              type: 'loading',\n              context,\n              variables: this.state.variables,\n            })\n          }\n        })\n    }\n\n    return promise\n      .then(() => this.executeMutation())\n      .then(result => {\n        data = result\n      })\n      .then(() =>\n        this.options.onSuccess?.(\n          data,\n          this.state.variables!,\n          this.state.context!\n        )\n      )\n      .then(() =>\n        this.options.onSettled?.(\n          data,\n          null,\n          this.state.variables!,\n          this.state.context\n        )\n      )\n      .then(() => {\n        this.dispatch({ type: 'success', data })\n        return data\n      })\n      .catch(error => {\n        getLogger().error(error)\n        return Promise.resolve()\n          .then(() =>\n            this.options.onError?.(\n              error,\n              this.state.variables!,\n              this.state.context\n            )\n          )\n          .then(() =>\n            this.options.onSettled?.(\n              undefined,\n              error,\n              this.state.variables!,\n              this.state.context\n            )\n          )\n          .then(() => {\n            this.dispatch({ type: 'error', error })\n            throw error\n          })\n      })\n  }\n\n  private executeMutation(): Promise<TData> {\n    this.retryer = new Retryer({\n      fn: () => {\n        if (!this.options.mutationFn) {\n          return Promise.reject('No mutationFn found')\n        }\n        return this.options.mutationFn(this.state.variables!)\n      },\n      onFail: () => {\n        this.dispatch({ type: 'failed' })\n      },\n      onPause: () => {\n        this.dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.dispatch({ type: 'continue' })\n      },\n      retry: this.options.retry ?? 0,\n      retryDelay: this.options.retryDelay,\n    })\n\n    return this.retryer.promise\n  }\n\n  private dispatch(action: Action<TData, TError, TVariables, TContext>): void {\n    this.state = reducer(this.state, action)\n\n    this.observers.forEach(observer => {\n      observer.onMutationUpdate(action)\n    })\n    this.mutationCache.notify(this)\n  }\n}\n\nexport function getDefaultState<\n  TData,\n  TError,\n  TVariables,\n  TContext\n>(): MutationState<TData, TError, TVariables, TContext> {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined,\n  }\n}\n\nfunction reducer<TData, TError, TVariables, TContext>(\n  state: MutationState<TData, TError, TVariables, TContext>,\n  action: Action<TData, TError, TVariables, TContext>\n): MutationState<TData, TError, TVariables, TContext> {\n  switch (action.type) {\n    case 'failed':\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n      }\n    case 'pause':\n      return {\n        ...state,\n        isPaused: true,\n      }\n    case 'continue':\n      return {\n        ...state,\n        isPaused: false,\n      }\n    case 'loading':\n      return {\n        ...state,\n        context: action.context,\n        data: undefined,\n        error: null,\n        isPaused: false,\n        status: 'loading',\n        variables: action.variables,\n      }\n    case 'success':\n      return {\n        ...state,\n        data: action.data,\n        error: null,\n        status: 'success',\n        isPaused: false,\n      }\n    case 'error':\n      return {\n        ...state,\n        data: undefined,\n        error: action.error,\n        failureCount: state.failureCount + 1,\n        isPaused: false,\n        status: 'error',\n      }\n    case 'setState':\n      return {\n        ...state,\n        ...action.state,\n      }\n    default:\n      return state\n  }\n}\n","import type { MutationOptions } from './types'\nimport type { QueryClient } from './queryClient'\nimport { Mutation, MutationState } from './mutation'\nimport { noop } from './utils'\nimport { Subscribable } from './subscribable'\n\n// TYPES\n\ntype MutationCacheListener = (mutation?: Mutation) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  private mutations: Mutation<any, any, any, any>[]\n  private mutationId: number\n\n  constructor() {\n    super()\n    this.mutations = []\n    this.mutationId = 0\n  }\n\n  build<TData, TError, TVariables, TContext>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n    state?: MutationState<TData, TError, TVariables, TContext>\n  ): Mutation<TData, TError, TVariables, TContext> {\n    const mutation = new Mutation({\n      mutationCache: this,\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey\n        ? client.getMutationDefaults(options.mutationKey)\n        : undefined,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    this.mutations.push(mutation)\n    this.notify(mutation)\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    this.mutations = this.mutations.filter(x => x !== mutation)\n    mutation.cancel()\n    this.notify(mutation)\n  }\n\n  clear(): void {\n    this.mutations.forEach(mutation => {\n      this.remove(mutation)\n    })\n  }\n\n  getAll(): Mutation[] {\n    return this.mutations\n  }\n\n  notify(mutation?: Mutation<any, any, any, any>) {\n    this.listeners.forEach(listener => {\n      listener(mutation)\n    })\n  }\n\n  onFocus(): void {\n    this.resumePausedMutations()\n  }\n\n  onOnline(): void {\n    this.resumePausedMutations()\n  }\n\n  resumePausedMutations(): Promise<void> {\n    const pausedMutations = this.mutations.filter(x => x.state.isPaused)\n\n    return pausedMutations.reduce(\n      (promise, mutation) =>\n        promise.then(() => mutation.continue().catch(noop)),\n      Promise.resolve()\n    )\n  }\n}\n","import type { QueryBehavior } from './query'\nimport { isCancelable } from './retryer'\nimport type { InfiniteData, QueryFunctionContext, QueryOptions } from './types'\n\nexport function infiniteQueryBehavior<\n  TQueryFnData,\n  TError,\n  TData\n>(): QueryBehavior<TQueryFnData, TError, InfiniteData<TData>> {\n  return {\n    onFetch: context => {\n      context.fetchFn = () => {\n        const fetchMore = context.fetchOptions?.meta?.fetchMore\n        const pageParam = fetchMore?.pageParam\n        const isFetchingNextPage = fetchMore?.direction === 'forward'\n        const isFetchingPreviousPage = fetchMore?.direction === 'backward'\n        const oldPages = context.state.data?.pages || []\n        const oldPageParams = context.state.data?.pageParams || []\n        let newPageParams = oldPageParams\n\n        // Get query function\n        const queryFn =\n          context.options.queryFn || (() => Promise.reject('Missing queryFn'))\n\n        // Create function to fetch a page\n        const fetchPage = (\n          pages: unknown[],\n          manual?: boolean,\n          param?: unknown,\n          previous?: boolean\n        ): Promise<unknown[]> => {\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages)\n          }\n\n          const queryFnContext: QueryFunctionContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n          }\n\n          let cancelFn: undefined | (() => any)\n          const queryFnResult = queryFn(queryFnContext)\n          if ((queryFnResult as any).cancel) {\n            cancelFn = (queryFnResult as any).cancel\n          }\n\n          const promise = Promise.resolve(queryFnResult).then(page => {\n            newPageParams = previous\n              ? [param, ...newPageParams]\n              : [...newPageParams, param]\n            return previous ? [page, ...pages] : [...pages, page]\n          })\n\n          if (cancelFn) {\n            const promiseAsAny = promise as any\n            promiseAsAny.cancel = cancelFn\n          }\n\n          return promise\n        }\n\n        let promise\n\n        // Fetch first page?\n        if (!oldPages.length) {\n          promise = fetchPage([])\n        }\n\n        // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getNextPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param)\n        }\n\n        // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getPreviousPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param, true)\n        }\n\n        // Refetch pages\n        else {\n          newPageParams = []\n\n          const manual = typeof context.options.getNextPageParam === 'undefined'\n\n          // Fetch first page\n          promise = fetchPage([], manual, oldPageParams[0])\n\n          // Fetch remaining pages\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then(pages => {\n              const param = manual\n                ? oldPageParams[i]\n                : getNextPageParam(context.options, pages)\n              return fetchPage(pages, manual, param)\n            })\n          }\n        }\n\n        const finalPromise = promise.then(pages => ({\n          pages,\n          pageParams: newPageParams,\n        }))\n\n        if (isCancelable(promise)) {\n          const finalPromiseAsAny = finalPromise as any\n          finalPromiseAsAny.cancel = promise.cancel\n        }\n\n        return finalPromise\n      }\n    },\n  }\n}\n\nexport function getNextPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[]\n): unknown | undefined {\n  return options.getNextPageParam?.(pages[pages.length - 1], pages)\n}\n\nexport function getPreviousPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[]\n): unknown | undefined {\n  return options.getPreviousPageParam?.(pages[0], pages)\n}\n\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasNextPage(\n  options: QueryOptions<any, any>,\n  pages?: unknown\n): boolean | undefined {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages)\n    return (\n      typeof nextPageParam !== 'undefined' &&\n      nextPageParam !== null &&\n      nextPageParam !== false\n    )\n  }\n}\n\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasPreviousPage(\n  options: QueryOptions<any, any>,\n  pages?: unknown\n): boolean | undefined {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages)\n    return (\n      typeof previousPageParam !== 'undefined' &&\n      previousPageParam !== null &&\n      previousPageParam !== false\n    )\n  }\n}\n","import {\n  QueryFilters,\n  Updater,\n  hashQueryKey,\n  noop,\n  parseFilterArgs,\n  parseQueryArgs,\n  partialMatchKey,\n} from './utils'\nimport type {\n  DefaultOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryKeyWithRef,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  ResetOptions,\n} from './types'\nimport type { QueryState, SetDataOptions } from './query'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { CancelOptions } from './retryer'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\n\n// TYPES\n\ninterface QueryClientConfig {\n  queryCache?: QueryCache\n  mutationCache?: MutationCache\n  defaultOptions?: DefaultOptions\n}\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: QueryOptions<any, any, any>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  private queryCache: QueryCache\n  private mutationCache: MutationCache\n  private defaultOptions: DefaultOptions\n  private queryDefaults: QueryDefaults[]\n  private mutationDefaults: MutationDefaults[]\n  private unsubscribeFocus?: () => void\n  private unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.queryCache = config.queryCache || new QueryCache()\n    this.mutationCache = config.mutationCache || new MutationCache()\n    this.defaultOptions = config.defaultOptions || {}\n    this.queryDefaults = []\n    this.mutationDefaults = []\n  }\n\n  mount(): void {\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused() && onlineManager.isOnline()) {\n        this.mutationCache.onFocus()\n        this.queryCache.onFocus()\n      }\n    })\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (focusManager.isFocused() && onlineManager.isOnline()) {\n        this.mutationCache.onOnline()\n        this.queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.unsubscribeFocus?.()\n    this.unsubscribeOnline?.()\n  }\n\n  isFetching(filters?: QueryFilters): number\n  isFetching(queryKey?: QueryKeyWithRef, filters?: QueryFilters): number\n  isFetching(\n    arg1?: QueryKeyWithRef | QueryFilters,\n    arg2?: QueryFilters\n  ): number {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    filters.fetching = true\n    return this.queryCache.findAll(filters).length\n  }\n\n  getQueryData<TData = unknown>(\n    queryKey: QueryKey,\n    filters?: QueryFilters\n  ): TData | undefined {\n    return this.queryCache.find<TData>(queryKey, filters)?.state.data\n  }\n\n  setQueryData<TData>(\n    queryKey: QueryKeyWithRef,\n    updater: Updater<TData | undefined, TData>,\n    options?: SetDataOptions\n  ): TData {\n    const parsedOptions = parseQueryArgs(queryKey)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n    return this.queryCache\n      .build(this, defaultedOptions)\n      .setData(updater, options)\n  }\n\n  getQueryState<TData = unknown, TError = undefined>(\n    queryKey: QueryKeyWithRef,\n    filters?: QueryFilters\n  ): QueryState<TData, TError> | undefined {\n    return this.queryCache.find<TData, TError>(queryKey, filters)?.state\n  }\n\n  removeQueries(filters?: QueryFilters): void\n  removeQueries(queryKey?: QueryKeyWithRef, filters?: QueryFilters): void\n  removeQueries(\n    arg1?: QueryKeyWithRef | QueryFilters,\n    arg2?: QueryFilters\n  ): void {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    const queryCache = this.queryCache\n    queryCache.findAll(filters).forEach(query => {\n      queryCache.remove(query)\n    })\n  }\n\n  resetQueries(filters?: QueryFilters, options?: ResetOptions): Promise<void>\n  resetQueries(\n    queryKey?: QueryKeyWithRef,\n    filters?: QueryFilters,\n    options?: ResetOptions\n  ): Promise<void>\n  resetQueries(\n    arg1?: QueryKeyWithRef | QueryFilters,\n    arg2?: QueryFilters | ResetOptions,\n    arg3?: ResetOptions\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n    const queryCache = this.queryCache\n\n    const refetchFilters: QueryFilters = {\n      ...filters,\n      active: true,\n    }\n\n    queryCache.findAll(filters).forEach(query => {\n      query.reset()\n    })\n    return this.refetchQueries(refetchFilters, options)\n  }\n\n  cancelQueries(filters?: QueryFilters, options?: CancelOptions): Promise<void>\n  cancelQueries(\n    queryKey?: QueryKeyWithRef,\n    filters?: QueryFilters,\n    options?: CancelOptions\n  ): Promise<void>\n  cancelQueries(\n    arg1?: QueryKeyWithRef | QueryFilters,\n    arg2?: QueryFilters | CancelOptions,\n    arg3?: CancelOptions\n  ): Promise<void> {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3)\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true\n    }\n\n    const promises = this.queryCache\n      .findAll(filters)\n      .map(query => query.cancel(cancelOptions))\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries(\n    filters?: InvalidateQueryFilters,\n    options?: InvalidateOptions\n  ): Promise<void>\n  invalidateQueries(\n    queryKey?: QueryKeyWithRef,\n    filters?: InvalidateQueryFilters,\n    options?: InvalidateOptions\n  ): Promise<void>\n  invalidateQueries(\n    arg1?: QueryKeyWithRef | InvalidateQueryFilters,\n    arg2?: InvalidateQueryFilters | InvalidateOptions,\n    arg3?: InvalidateOptions\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    const refetchFilters: QueryFilters = {\n      ...filters,\n      active: filters.refetchActive ?? true,\n      inactive: filters.refetchInactive ?? false,\n    }\n\n    this.queryCache.findAll(filters).forEach(query => {\n      query.invalidate()\n    })\n    return this.refetchQueries(refetchFilters, options)\n  }\n\n  refetchQueries(\n    filters?: QueryFilters,\n    options?: RefetchOptions\n  ): Promise<void>\n  refetchQueries(\n    queryKey?: QueryKeyWithRef,\n    filters?: QueryFilters,\n    options?: RefetchOptions\n  ): Promise<void>\n  refetchQueries(\n    arg1?: QueryKeyWithRef | QueryFilters,\n    arg2?: QueryFilters | RefetchOptions,\n    arg3?: RefetchOptions\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    const promises = this.queryCache\n      .findAll(filters)\n      .map(query => query.fetch())\n\n    let promise = Promise.all(promises).then(noop)\n\n    if (!options?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  fetchQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    options: FetchQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<TData>\n  fetchQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    queryKey: QueryKeyWithRef,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<TData>\n  fetchQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    queryKey: QueryKeyWithRef,\n    queryFn: QueryFunction<TQueryFnData>,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<TData>\n  fetchQuery<TQueryFnData, TError, TData = TQueryFnData>(\n    arg1: QueryKeyWithRef | FetchQueryOptions<TQueryFnData, TError, TData>,\n    arg2?:\n      | QueryFunction<TQueryFnData>\n      | FetchQueryOptions<TQueryFnData, TError, TData>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<TData> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions)\n\n    // @ts-ignore\n    return query.isStaleByTime(defaultedOptions.staleTime)\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery(options: FetchQueryOptions): Promise<void>\n  prefetchQuery(queryKey: QueryKey, options?: FetchQueryOptions): Promise<void>\n  prefetchQuery(\n    queryKey: QueryKey,\n    queryFn: QueryFunction,\n    options?: FetchQueryOptions\n  ): Promise<void>\n  prefetchQuery(\n    arg1: QueryKey | FetchQueryOptions,\n    arg2?: QueryFunction | FetchQueryOptions,\n    arg3?: FetchQueryOptions\n  ): Promise<void> {\n    return this.fetchQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData\n  >(\n    queryKey: QueryKey,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData\n  >(\n    queryKey: QueryKey,\n    queryFn: QueryFunction<TQueryFnData>,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<TQueryFnData, TError, TData = TQueryFnData>(\n    arg1: QueryKey | FetchInfiniteQueryOptions<TQueryFnData, TError, TData>,\n    arg2?:\n      | QueryFunction<TQueryFnData>\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData>,\n    arg3?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<InfiniteData<TData>> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    parsedOptions.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData\n    >()\n    return this.fetchQuery(parsedOptions)\n  }\n\n  prefetchInfiniteQuery(options: FetchInfiniteQueryOptions): Promise<void>\n  prefetchInfiniteQuery(\n    queryKey: QueryKeyWithRef,\n    options?: FetchInfiniteQueryOptions\n  ): Promise<void>\n  prefetchInfiniteQuery(\n    queryKey: QueryKeyWithRef,\n    queryFn: QueryFunction,\n    options?: FetchInfiniteQueryOptions\n  ): Promise<void>\n  prefetchInfiniteQuery(\n    arg1: QueryKeyWithRef | FetchInfiniteQueryOptions,\n    arg2?: QueryFunction | FetchInfiniteQueryOptions,\n    arg3?: FetchInfiniteQueryOptions\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  cancelMutations(): Promise<void> {\n    const promises = this.mutationCache\n      .getAll()\n      .map(mutation => mutation.cancel())\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  resumePausedMutations(): Promise<void> {\n    return this.getMutationCache().resumePausedMutations()\n  }\n\n  executeMutation<\n    TData = unknown,\n    TError = unknown,\n    TVariables = void,\n    TContext = unknown\n  >(\n    options: MutationOptions<TData, TError, TVariables, TContext>\n  ): Promise<TData> {\n    return this.mutationCache.build(this, options).execute()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.mutationCache\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.defaultOptions = options\n  }\n\n  setQueryDefaults(\n    queryKey: QueryKey,\n    options: QueryObserverOptions<any, any, any, any>\n  ): void {\n    const result = this.queryDefaults.find(\n      x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey)\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.queryDefaults.push({ queryKey, defaultOptions: options })\n    }\n  }\n\n  getQueryDefaults(\n    queryKey?: QueryKey\n  ): QueryObserverOptions<any, any, any, any> | undefined {\n    return queryKey\n      ? this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey))\n          ?.defaultOptions\n      : undefined\n  }\n\n  setMutationDefaults(\n    mutationKey: MutationKey,\n    options: MutationObserverOptions<any, any, any, any>\n  ): void {\n    const result = this.mutationDefaults.find(\n      x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey)\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.mutationDefaults.push({ mutationKey, defaultOptions: options })\n    }\n  }\n\n  getMutationDefaults(\n    mutationKey?: MutationKey\n  ): MutationObserverOptions<any, any, any, any> | undefined {\n    return mutationKey\n      ? this.mutationDefaults.find(x =>\n          partialMatchKey(mutationKey, x.mutationKey)\n        )?.defaultOptions\n      : undefined\n  }\n\n  defaultQueryOptions<T extends QueryOptions<any, any, any>>(options?: T): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options?.queryKey),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  defaultQueryObserverOptions<\n    T extends QueryObserverOptions<any, any, any, any>\n  >(options?: T): T {\n    return this.defaultQueryOptions(options)\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options?.mutationKey),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.queryCache.clear()\n    this.mutationCache.clear()\n  }\n}\n","import { reactive, readonly } from 'vue'\n\nimport {\n  getStatusProps,\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceEqualDeep,\n  timeUntilStale,\n} from './utils'\nimport type {\n  PlaceholderDataFunction,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n  ResultOptions,\n} from './types'\nimport type { Query, QueryState, Action, FetchOptions } from './query'\nimport type { QueryClient } from './queryClient'\nimport { focusManager } from './focusManager'\nimport { Subscribable } from './subscribable'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>\n) => void\n\ninterface NotifyOptions {\n  cache?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\nexport interface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  options: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>\n\n  private client: QueryClient\n  private currentQuery!: Query<TQueryFnData, TError, TQueryData>\n  private currentResult!: QueryObserverResult<TData, TError>\n  private readonlyResult!: QueryObserverResult<TData, TError>\n  private currentResultState?: QueryState<TQueryData, TError>\n  private previousQueryResult?: QueryObserverResult<TData, TError>\n  private initialDataUpdateCount: number\n  private initialErrorUpdateCount: number\n  private staleTimeoutId?: number\n  private refetchIntervalId?: number\n\n  constructor(\n    client: QueryClient,\n    options: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>\n  ) {\n    super()\n\n    this.client = client\n    this.options = options\n    this.initialDataUpdateCount = 0\n    this.initialErrorUpdateCount = 0\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.remove = this.remove.bind(this)\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.length === 1) {\n      this.updateQuery()\n\n      this.currentQuery.addObserver(this)\n\n      if (this.willFetchOnMount()) {\n        this.executeFetch()\n      }\n\n      this.updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.destroy()\n    }\n  }\n\n  willLoadOnMount(): boolean {\n    return (\n      this.options.enabled !== false && !this.currentQuery.state.dataUpdatedAt\n    )\n  }\n\n  willRefetchOnMount(): boolean {\n    return (\n      this.options.enabled !== false &&\n      this.currentQuery.state.dataUpdatedAt > 0 &&\n      (this.options.refetchOnMount === 'always' ||\n        (this.options.refetchOnMount !== false && this.isStale()))\n    )\n  }\n\n  willFetchOnMount(): boolean {\n    return this.willLoadOnMount() || this.willRefetchOnMount()\n  }\n\n  willFetchOnReconnect(): boolean {\n    return (\n      this.options.enabled !== false &&\n      (this.options.refetchOnReconnect === 'always' ||\n        (this.options.refetchOnReconnect !== false && this.isStale()))\n    )\n  }\n\n  willFetchOnWindowFocus(): boolean {\n    return (\n      this.options.enabled !== false &&\n      (this.options.refetchOnWindowFocus === 'always' ||\n        (this.options.refetchOnWindowFocus !== false && this.isStale()))\n    )\n  }\n\n  private willFetchOptionally(): boolean {\n    return this.options.enabled !== false && this.isStale()\n  }\n\n  private isStale(): boolean {\n    return this.currentQuery.isStaleByTime(this.options.staleTime)\n  }\n\n  destroy(): void {\n    this.listeners = []\n    this.clearTimers()\n    this.currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options?: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>\n  ): void {\n    const prevOptions = { ...this.options }\n    const prevQuery = this.currentQuery\n\n    this.options = this.client.defaultQueryObserverOptions(options)\n\n    if (\n      typeof this.options.enabled !== 'undefined' &&\n      typeof this.options.enabled !== 'boolean'\n    ) {\n      throw new Error('Expected enabled to be a boolean')\n    }\n\n    // Keep previous query key if the user does not supply one\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey\n    }\n\n    this.updateQuery()\n\n    // Take no further actions if there are no subscribers\n    if (!this.listeners.length) {\n      return\n    }\n\n    // If we subscribed to a new query, optionally fetch and update refetch\n    if (this.currentQuery !== prevQuery) {\n      this.optionalFetch()\n      this.updateTimers()\n      return\n    }\n\n    // Optionally fetch if the query became enabled\n    if (this.options.enabled !== false && prevOptions.enabled === false) {\n      this.optionalFetch()\n    }\n\n    // Update stale interval if needed\n    if (\n      this.options.enabled !== prevOptions.enabled ||\n      this.options.staleTime !== prevOptions.staleTime\n    ) {\n      this.updateStaleTimeout()\n    }\n\n    // Update refetch interval if needed\n    if (\n      this.options.enabled !== prevOptions.enabled ||\n      this.options.refetchInterval !== prevOptions.refetchInterval\n    ) {\n      this.updateRefetchInterval()\n    }\n  }\n\n  protected getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.currentResult\n  }\n\n  getReadonlyResult(): QueryObserverResult<TData, TError> {\n    return (\n      this.readonlyResult ||\n      (this.readonlyResult = readonly(\n        this.currentResult\n      ) as QueryObserverResult<TData, TError>)\n    )\n  }\n\n  getNextResult(\n    options?: ResultOptions\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return new Promise((resolve, reject) => {\n      const unsubscribe = this.subscribe(result => {\n        if (!result.isFetching) {\n          unsubscribe()\n          if (result.isError && options?.throwOnError) {\n            reject(result.error)\n          } else {\n            resolve(result)\n          }\n        }\n      })\n    })\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData> {\n    return this.currentQuery\n  }\n\n  remove(): void {\n    this.client.getQueryCache().remove(this.currentQuery)\n  }\n\n  refetch(\n    options?: RefetchOptions\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.fetch(options)\n  }\n\n  protected fetch(\n    fetchOptions?: ObserverFetchOptions\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.executeFetch(fetchOptions).then(() => {\n      this.updateResult()\n      return this.currentResult\n    })\n  }\n\n  private optionalFetch(): void {\n    if (this.willFetchOptionally()) {\n      this.executeFetch()\n    }\n  }\n\n  private executeFetch(\n    fetchOptions?: ObserverFetchOptions\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData>,\n      fetchOptions\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  private updateStaleTimeout(): void {\n    this.clearStaleTimeout()\n\n    if (\n      isServer ||\n      this.currentResult.isStale ||\n      !isValidTimeout(this.options.staleTime)\n    ) {\n      return\n    }\n\n    const time = timeUntilStale(\n      this.currentResult.dataUpdatedAt,\n      this.options.staleTime\n    )\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult()\n        this.notify({\n          cache: true,\n        })\n      }\n    }, timeout)\n  }\n\n  private updateRefetchInterval(): void {\n    this.clearRefetchInterval()\n\n    if (\n      isServer ||\n      this.options.enabled === false ||\n      !isValidTimeout(this.options.refetchInterval)\n    ) {\n      return\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.executeFetch()\n      }\n    }, this.options.refetchInterval)\n  }\n\n  private updateTimers(): void {\n    this.updateStaleTimeout()\n    this.updateRefetchInterval()\n  }\n\n  private clearTimers(): void {\n    this.clearStaleTimeout()\n    this.clearRefetchInterval()\n  }\n\n  private clearStaleTimeout(): void {\n    clearTimeout(this.staleTimeoutId)\n    this.staleTimeoutId = undefined\n  }\n\n  private clearRefetchInterval(): void {\n    clearInterval(this.refetchIntervalId)\n    this.refetchIntervalId = undefined\n  }\n\n  protected updateResult(willFetch?: boolean) {\n    const { state } = this.currentQuery\n    let { isFetching, status } = state\n    let isPreviousData = false\n    let isPlaceholderData = false\n    let data: TData | undefined\n    let dataUpdatedAt = state.dataUpdatedAt\n\n    // Optimistically set status to loading if we will start fetching\n    if (willFetch) {\n      isFetching = true\n      if (status === 'idle') {\n        status = 'loading'\n      }\n    }\n\n    // Keep previous data if needed\n    if (\n      this.options.keepPreviousData &&\n      !state.dataUpdateCount &&\n      this.previousQueryResult?.isSuccess\n    ) {\n      data = this.previousQueryResult.data\n      dataUpdatedAt = this.previousQueryResult.dataUpdatedAt\n      status = this.previousQueryResult.status\n      isPreviousData = true\n    }\n    // Select data if needed\n    else if (this.options.select && typeof state.data !== 'undefined') {\n      // Use the previous select result if the query data did not change\n      if (this.currentResult && state.data === this.currentResultState?.data) {\n        data = this.currentResult.data\n      } else {\n        data = this.options.select(state.data)\n        if (this.options.structuralSharing !== false) {\n          data = replaceEqualDeep(this.currentResult?.data, data)\n        }\n      }\n    }\n    // Use query data\n    else {\n      data = (state.data as unknown) as TData\n    }\n\n    // Show placeholder data if needed\n    if (\n      typeof this.options.placeholderData !== 'undefined' &&\n      typeof data === 'undefined' &&\n      status === 'loading'\n    ) {\n      const placeholderData =\n        typeof this.options.placeholderData === 'function'\n          ? (this.options.placeholderData as PlaceholderDataFunction<TData>)()\n          : this.options.placeholderData\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success'\n        data = placeholderData\n        isPlaceholderData = true\n      }\n    }\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      ...getStatusProps(status),\n      data,\n      dataUpdatedAt,\n      error: state.error,\n      errorUpdatedAt: state.errorUpdateCount,\n      failureCount: state.fetchFailureCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        state.dataUpdateCount > this.initialDataUpdateCount ||\n        state.errorUpdateCount > this.initialErrorUpdateCount,\n      isFetching,\n      isLoadingError: status === 'error' && state.dataUpdatedAt === 0,\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: status === 'error' && state.dataUpdatedAt !== 0,\n      isStale: this.isStale(),\n      refetch: this.refetch,\n      remove: this.remove,\n    }\n\n    if (this.currentResult) {\n      Object.assign(this.currentResult, result)\n    } else {\n      this.currentResult = reactive(result) as QueryObserverResult<\n        TData,\n        TError\n      >\n    }\n  }\n\n  private updateQuery(): void {\n    const prevQuery = this.currentQuery\n\n    const query = this.client\n      .getQueryCache()\n      .build(\n        this.client,\n        this.options as QueryOptions<TQueryFnData, TError, TQueryData>\n      )\n\n    if (query === prevQuery) {\n      return\n    }\n\n    this.previousQueryResult = { ...this.currentResult }\n    this.currentQuery = query\n    this.initialDataUpdateCount = query.state.dataUpdateCount\n    this.initialErrorUpdateCount = query.state.errorUpdateCount\n\n    const willFetch = prevQuery\n      ? this.willFetchOptionally()\n      : this.willFetchOnMount()\n\n    this.updateResult(willFetch)\n\n    if (!this.hasListeners()) {\n      return\n    }\n\n    prevQuery?.removeObserver(this)\n    this.currentQuery.addObserver(this)\n\n    this.notify({})\n  }\n\n  onQueryUpdate(action: Action<TData, TError>): void {\n    this.updateResult()\n    // Update timers\n    this.updateTimers()\n\n    // Determine which callbacks to trigger\n    const notifyOptions: NotifyOptions = {}\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true\n    }\n\n    this.notify(notifyOptions)\n  }\n\n  private notify(notifyOptions: NotifyOptions): void {\n    // First trigger the configuration callbacks\n    if (notifyOptions.onSuccess) {\n      this.options.onSuccess?.(this.readonlyResult.data!)\n      this.options.onSettled?.(this.readonlyResult.data!, null)\n    } else if (notifyOptions.onError) {\n      this.options.onError?.(this.readonlyResult.error!)\n      this.options.onSettled?.(undefined, this.readonlyResult.error!)\n    }\n\n    // Then trigger the listeners\n    this.listeners.forEach(listener => {\n      listener(this.readonlyResult)\n    })\n\n    // Then the cache listeners\n    if (notifyOptions.cache) {\n      this.client.getQueryCache().notify(this.currentQuery)\n    }\n  }\n}\n","import { difference, getQueryKeyHashFn } from './utils'\nimport type { QueryObserverOptions, QueryObserverResult } from './types'\nimport type { QueryClient } from './queryClient'\nimport { QueryObserver } from './queryObserver'\nimport { Subscribable } from './subscribable'\n\ntype QueriesObserverListener = (result: QueryObserverResult[]) => void\n\nexport class QueriesObserver extends Subscribable<QueriesObserverListener> {\n  private client: QueryClient\n  private result!: QueryObserverResult[]\n  private queries: QueryObserverOptions[]\n  private observers: QueryObserver[]\n\n  constructor(client: QueryClient, queries?: QueryObserverOptions[]) {\n    super()\n\n    this.client = client\n    this.queries = queries || []\n    this.observers = []\n\n    // Subscribe to queries\n    this.updateObservers()\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.length === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result)\n        })\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.destroy()\n    }\n  }\n\n  destroy(): void {\n    this.listeners = []\n    this.observers.forEach(observer => {\n      observer.destroy()\n    })\n  }\n\n  setQueries(queries: QueryObserverOptions[]): void {\n    this.queries = queries\n    this.updateObservers()\n  }\n\n  getCurrentResult(): QueryObserverResult[] {\n    return this.result\n  }\n\n  private updateObservers(): void {\n    let hasIndexChange = false\n\n    const prevObservers = this.observers\n    const newObservers = this.queries.map((options, i) => {\n      let observer: QueryObserver | undefined = prevObservers[i]\n\n      const defaultedOptions = this.client.defaultQueryObserverOptions(options)\n      const hashFn = getQueryKeyHashFn(defaultedOptions)\n      defaultedOptions.queryHash = hashFn(defaultedOptions.queryKey!)\n\n      if (\n        !observer ||\n        observer.getCurrentQuery().queryHash !== defaultedOptions.queryHash\n      ) {\n        hasIndexChange = true\n        observer = prevObservers.find(\n          x => x.getCurrentQuery().queryHash === defaultedOptions.queryHash\n        )\n      }\n\n      if (observer) {\n        observer.setOptions(defaultedOptions)\n        return observer\n      }\n\n      return new QueryObserver(this.client, defaultedOptions)\n    })\n\n    if (prevObservers.length === newObservers.length && !hasIndexChange) {\n      return\n    }\n\n    this.observers = newObservers\n    this.result = newObservers.map(observer => observer.getReadonlyResult())\n\n    if (!this.listeners.length) {\n      return\n    }\n\n    difference(prevObservers, newObservers).forEach(observer => {\n      observer.destroy()\n    })\n\n    difference(newObservers, prevObservers).forEach(observer => {\n      observer.subscribe(result => {\n        this.onUpdate(observer, result)\n      })\n    })\n\n    this.notify()\n  }\n\n  private onUpdate(observer: QueryObserver, result: QueryObserverResult): void {\n    const index = this.observers.indexOf(observer)\n    if (index !== -1) {\n      this.result[index] = result\n      this.notify()\n    }\n  }\n\n  private notify(): void {\n    this.listeners.forEach(listener => {\n      listener(this.result)\n    })\n  }\n}\n","import type {\n  FetchNextPageOptions,\n  FetchPreviousPageOptions,\n  InfiniteData,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport { ObserverFetchOptions, QueryObserver } from './queryObserver'\nimport {\n  hasNextPage,\n  hasPreviousPage,\n  infiniteQueryBehavior,\n} from './infiniteQueryBehavior'\n\ntype InfiniteQueryObserverListener<TData, TError> = (\n  result: InfiniteQueryObserverResult<TData, TError>\n) => void\n\nexport class InfiniteQueryObserver<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData\n> extends QueryObserver<\n  TQueryFnData,\n  TError,\n  InfiniteData<TData>,\n  InfiniteData<TQueryData>\n> {\n  // Type override\n  subscribe!: (\n    listener?: InfiniteQueryObserverListener<TData, TError>\n  ) => () => void\n\n  // Type override\n  getCurrentResult!: () => InfiniteQueryObserverResult<TData, TError>\n\n  // Type override\n  protected fetch!: (\n    fetchOptions?: ObserverFetchOptions\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(\n    client: QueryClient,\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData\n    >\n  ) {\n    super(client, options)\n  }\n\n  protected bindMethods(): void {\n    super.bindMethods()\n    this.fetchNextPage = this.fetchNextPage.bind(this)\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this)\n  }\n\n  setOptions(\n    options?: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData\n    >\n  ): void {\n    super.setOptions({\n      ...options,\n      behavior: infiniteQueryBehavior<TQueryFnData, TError, TData>(),\n    })\n  }\n\n  fetchNextPage(\n    options?: FetchNextPageOptions\n  ): Promise<InfiniteQueryObserverResult<TData, TError>> {\n    return this.fetch({\n      cancelRefetch: true,\n      throwOnError: options?.throwOnError,\n      meta: {\n        fetchMore: { direction: 'forward', pageParam: options?.pageParam },\n      },\n    })\n  }\n\n  fetchPreviousPage(\n    options?: FetchPreviousPageOptions\n  ): Promise<InfiniteQueryObserverResult<TData, TError>> {\n    return this.fetch({\n      cancelRefetch: true,\n      throwOnError: options?.throwOnError,\n      meta: {\n        fetchMore: { direction: 'backward', pageParam: options?.pageParam },\n      },\n    })\n  }\n\n  protected updateResult(willFetch?: boolean) {\n    const { state } = this.getCurrentQuery()\n    super.updateResult(willFetch)\n\n    Object.assign(super.getCurrentResult(), {\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(this.options, state.data?.pages),\n      hasPreviousPage: hasPreviousPage(this.options, state.data?.pages),\n      isFetchingNextPage:\n        state.isFetching && state.fetchMeta?.fetchMore?.direction === 'forward',\n      isFetchingPreviousPage:\n        state.isFetching &&\n        state.fetchMeta?.fetchMore?.direction === 'backward',\n    })\n  }\n}\n","import { Action, getDefaultState, Mutation } from './mutation'\nimport type { QueryClient } from './queryClient'\nimport { Subscribable } from './subscribable'\nimport type {\n  MutateOptions,\n  MutationObserverResult,\n  MutationObserverOptions,\n} from './types'\nimport { getStatusProps } from './utils'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TContext> = (\n  result: MutationObserverResult<TData, TError, TVariables, TContext>\n) => void\n\ninterface NotifyOptions {\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TContext>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TContext>\n\n  private client: QueryClient\n  private currentResult!: MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >\n  private currentMutation?: Mutation<TData, TError, TVariables, TContext>\n  private mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>\n  ) {\n    super()\n\n    this.client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options?: MutationObserverOptions<TData, TError, TVariables, TContext>\n  ) {\n    this.options = this.client.defaultMutationOptions(options)\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void {\n    this.updateResult()\n\n    // Determine which callbacks to trigger\n    const notifyOptions: NotifyOptions = {\n      listeners: true,\n    }\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true\n    }\n\n    this.notify(notifyOptions)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  > {\n    return this.currentResult\n  }\n\n  reset(): void {\n    this.currentMutation = undefined\n    this.updateResult()\n    this.notify({ listeners: true })\n  }\n\n  mutate(\n    variables?: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>\n  ): Promise<TData> {\n    this.mutateOptions = options\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this)\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, {\n      ...this.options,\n      variables: variables ?? this.options.variables,\n    })\n\n    this.currentMutation.addObserver(this)\n\n    return this.currentMutation.execute()\n  }\n\n  private updateResult(): void {\n    const state = this.currentMutation\n      ? this.currentMutation.state\n      : getDefaultState<TData, TError, TVariables, TContext>()\n\n    this.currentResult = {\n      ...state,\n      ...getStatusProps(state.status),\n      mutate: this.mutate,\n      reset: this.reset,\n    }\n  }\n\n  private notify(options: NotifyOptions) {\n    // First trigger the mutate callbacks\n    if (this.mutateOptions) {\n      if (options.onSuccess) {\n        this.mutateOptions.onSuccess?.(\n          this.currentResult.data!,\n          this.currentResult.variables!,\n          this.currentResult.context!\n        )\n        this.mutateOptions.onSettled?.(\n          this.currentResult.data!,\n          null,\n          this.currentResult.variables!,\n          this.currentResult.context\n        )\n      } else if (options.onError) {\n        this.mutateOptions.onError?.(\n          this.currentResult.error!,\n          this.currentResult.variables!,\n          this.currentResult.context\n        )\n        this.mutateOptions.onSettled?.(\n          undefined,\n          this.currentResult.error,\n          this.currentResult.variables!,\n          this.currentResult.context\n        )\n      }\n    }\n\n    // Then trigger the listeners\n    if (options.listeners) {\n      this.listeners.forEach(listener => {\n        listener(this.currentResult)\n      })\n    }\n  }\n}\n","import type { Logger } from '../core/logger'\n\nexport const logger: Logger = console\n","import { setLogger } from '../core'\nimport { logger } from './logger'\n\nif (logger) {\n  setLogger(logger)\n}\n","import { defineComponent, inject, onMounted, onUnmounted, provide } from 'vue'\n\nimport { QueryClient } from '../core'\n\nconst symbol = Symbol('QueryClientProvider')\n\nexport const useQueryClient = () => {\n  const queryClient = inject<QueryClient | undefined>(symbol, undefined)\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return queryClient\n}\n\nexport interface QueryClientProviderProps {\n  client: QueryClient\n}\n\nexport const QueryClientProvider = defineComponent<QueryClientProviderProps>({\n  name: 'QueryClientProvider',\n  setup(props, { slots }) {\n    const { client } = props\n\n    provide(symbol, client)\n    onMounted(() => {\n      client.mount()\n    })\n    onUnmounted(() => {\n      client.unmount()\n    })\n\n    return slots.default?.()\n  },\n})\n","import { onMounted, onUnmounted, watchEffect } from 'vue'\n\nimport { QueryObserver } from '../core/queryObserver'\nimport { useQueryClient } from './QueryClientProvider'\nimport { UseBaseQueryOptions } from './types'\n\nexport function useBaseQuery<TQueryFnData, TError, TData, TQueryData>(\n  optionsFn: () => UseBaseQueryOptions<TQueryFnData, TError, TData, TQueryData>,\n  Observer: typeof QueryObserver\n) {\n  const queryClient = useQueryClient()\n\n  let observer!: QueryObserver<any, any, any, any>\n\n  watchEffect(() => {\n    const defaultedOptions = queryClient.defaultQueryObserverOptions(\n      optionsFn()\n    )\n\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly re-mounting after suspense\n    if (\n      defaultedOptions.suspense &&\n      typeof defaultedOptions.staleTime !== 'number'\n    ) {\n      defaultedOptions.staleTime = 1000\n    }\n\n    if (observer) {\n      // Update options\n      if (observer.hasListeners()) {\n        observer.setOptions(defaultedOptions)\n      }\n    } else {\n      // Create query observer\n      observer = new Observer(queryClient, defaultedOptions)\n    }\n  })\n\n  const currentResult = observer.getReadonlyResult()\n\n  // Subscribe to the observer\n  let unsubscribe: () => void\n  onMounted(() => {\n    unsubscribe = observer.subscribe()\n  })\n  onUnmounted(() => {\n    unsubscribe?.()\n  })\n\n  // Handle suspense\n  if (observer.options.suspense && currentResult.isLoading) {\n    const unsubscribe = observer.subscribe()\n    throw observer.refetch().finally(unsubscribe)\n  }\n\n  return currentResult\n}\n","import { QueryObserver } from '../core'\nimport { InfiniteQueryObserver } from '../core/infiniteQueryObserver'\nimport { QueryFunction, QueryKeyWithRef } from '../core/types'\nimport { parseQueryArgs } from '../core/utils'\nimport { UseInfiniteQueryOptionsWithRef, UseInfiniteQueryResult } from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\n\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n>(\n  options: UseInfiniteQueryOptionsWithRef<TQueryFnData, TError, TData>\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n>(\n  queryKey: QueryKeyWithRef,\n  options?: UseInfiniteQueryOptionsWithRef<TQueryFnData, TError, TData>\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n>(\n  queryKey: QueryKeyWithRef,\n  queryFn: QueryFunction<TQueryFnData>,\n  options?: UseInfiniteQueryOptionsWithRef<TQueryFnData, TError, TData>\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<TQueryFnData, TError, TData = TQueryFnData>(\n  arg1:\n    | QueryKeyWithRef\n    | UseInfiniteQueryOptionsWithRef<TQueryFnData, TError, TData>,\n  arg2?:\n    | QueryFunction<TQueryFnData>\n    | UseInfiniteQueryOptionsWithRef<TQueryFnData, TError, TData>,\n  arg3?: UseInfiniteQueryOptionsWithRef<TQueryFnData, TError, TData>\n): UseInfiniteQueryResult<TData, TError> {\n  return useBaseQuery(\n    () => parseQueryArgs(arg1, arg2, arg3),\n    InfiniteQueryObserver as typeof QueryObserver\n  ) as UseInfiniteQueryResult<TData, TError>\n}\n","import { onMounted, onUnmounted, ref, Ref } from 'vue'\n\nimport { QueryKeyWithRef } from '../core/types'\nimport { parseFilterArgs, QueryFilters } from '../core/utils'\nimport { useQueryClient } from './QueryClientProvider'\n\nexport function useIsFetching(filters?: QueryFilters): Ref<number>\nexport function useIsFetching(\n  queryKey?: QueryKeyWithRef,\n  filters?: QueryFilters\n): Ref<number>\nexport function useIsFetching(\n  arg1?: QueryKeyWithRef | QueryFilters,\n  arg2?: QueryFilters\n): Ref<number> {\n  const queryClient = useQueryClient()\n  const [filters] = parseFilterArgs(arg1, arg2)\n\n  const isFetching = ref<number>(queryClient.isFetching(filters))\n\n  let unsubscribe: () => void\n  onMounted(() => {\n    unsubscribe = queryClient.getQueryCache().subscribe(() => {\n      const newIsFetching = queryClient.isFetching(filters)\n      isFetching.value = newIsFetching\n    })\n  })\n  onUnmounted(() => {\n    unsubscribe?.()\n  })\n\n  return isFetching\n}\n","import { reactive, readonly, watchEffect, onMounted, onUnmounted } from 'vue'\n\nimport { noop, parseMutationArgs } from '../core/utils'\nimport { MutationObserver } from '../core/mutationObserver'\nimport { useQueryClient } from './QueryClientProvider'\nimport {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport {\n  MutationFunction,\n  MutationKey,\n  MutationObserverResult,\n} from '../core/types'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n>(\n  mutationFn: MutationFunction<TData, TVariables>,\n  options?: UseMutationOptions<TData, TError, TVariables, TContext>\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n>(\n  mutationKey: MutationKey,\n  options?: UseMutationOptions<TData, TError, TVariables, TContext>\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n>(\n  mutationKey: MutationKey,\n  mutationFn?: MutationFunction<TData, TVariables>,\n  options?: UseMutationOptions<TData, TError, TVariables, TContext>\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n>(\n  arg1:\n    | MutationKey\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg2?:\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg3?: UseMutationOptions<TData, TError, TVariables, TContext>\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const queryClient = useQueryClient()\n\n  // Create mutation observer\n  let observer: MutationObserver<TData, TError, TVariables, TContext>\n\n  // Create mutation currentResult\n  let currentResult!: UseMutationResult<TData, TError, TVariables, TContext>\n\n  watchEffect(() => {\n    const options = parseMutationArgs(arg1, arg2, arg3)\n\n    if (observer) {\n      // Update options\n      if (observer.hasListeners()) {\n        observer.setOptions(options)\n      } else {\n        // init observer & currentResult\n        observer = new MutationObserver(queryClient, options)\n\n        const mutate: UseMutateFunction<TData, TError, TVariables, TContext> = (\n          variables,\n          mutateOptions\n        ) => {\n          observer.mutate(variables, mutateOptions).catch(noop)\n        }\n\n        currentResult = reactive({\n          ...observer.getCurrentResult(),\n          mutate,\n          mutateAsync: observer.getCurrentResult().mutate,\n        }) as UseMutationResult<TData, TError, TVariables, TContext>\n      }\n    }\n  })\n\n  let unsubscribe: () => void\n  onMounted(() => {\n    // Subscribe to the observer\n    unsubscribe = observer.subscribe(\n      (result: MutationObserverResult<TData, TError, TVariables, TContext>) => {\n        // Check if the component is still mounted\n        if (observer.hasListeners()) {\n          Object.assign(currentResult, result)\n        }\n      }\n    )\n  })\n  onUnmounted(() => {\n    unsubscribe?.()\n  })\n\n  return readonly(currentResult) as UseMutationResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >\n}\n","import { reactive, readonly, watchEffect, onMounted, onUnmounted } from 'vue'\n\nimport { QueriesObserver } from '../core/queriesObserver'\nimport { useQueryClient } from './QueryClientProvider'\nimport { UseQueryOptions, UseQueryResult } from './types'\nimport { replaceShallowEqualDeep } from '../core/utils'\n\nexport function useQueries(queries: UseQueryOptions[]): UseQueryResult[] {\n  const queryClient = useQueryClient()\n\n  // Create queries observer\n  let observer!: QueriesObserver\n\n  watchEffect(() => {\n    if (observer) {\n      // Update queries\n      if (observer.hasListeners()) {\n        observer.setQueries(queries)\n      }\n    } else {\n      observer = new QueriesObserver(queryClient, queries)\n    }\n  })\n\n  const currentResult = reactive(observer.getCurrentResult())\n\n  let unsubscribe: () => void\n  // Subscribe to the observer\n  onMounted(() => {\n    unsubscribe = observer.subscribe(result => {\n      replaceShallowEqualDeep(currentResult, result)\n    })\n  })\n  onUnmounted(() => {\n    unsubscribe?.()\n  })\n\n  return readonly(currentResult) as UseQueryResult[]\n}\n","import { QueryObserver } from '../core'\nimport { QueryFunction, QueryKeyWithRef } from '../core/types'\nimport { parseQueryArgs } from '../core/utils'\nimport { UseQueryOptionsWithRef, UseQueryResult } from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n>(\n  options: UseQueryOptionsWithRef<TQueryFnData, TError, TData>\n): UseQueryResult<TData, TError>\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n>(\n  queryKey: QueryKeyWithRef,\n  options?: UseQueryOptionsWithRef<TQueryFnData, TError, TData>\n): UseQueryResult<TData, TError>\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n>(\n  queryKey: QueryKeyWithRef,\n  queryFn: QueryFunction<TQueryFnData>,\n  options?: UseQueryOptionsWithRef<TQueryFnData, TError, TData>\n): UseQueryResult<TData, TError>\nexport function useQuery<TQueryFnData, TError, TData = TQueryFnData>(\n  arg1: QueryKeyWithRef | UseQueryOptionsWithRef<TQueryFnData, TError, TData>,\n  arg2?:\n    | QueryFunction<TQueryFnData>\n    | UseQueryOptionsWithRef<TQueryFnData, TError, TData>,\n  arg3?: UseQueryOptionsWithRef<TQueryFnData, TError, TData>\n): UseQueryResult<TData, TError> {\n  return useBaseQuery(() => parseQueryArgs(arg1, arg2, arg3), QueryObserver)\n}\n"],"names":["_inheritsLoose","subClass","superClass","prototype","Object","create","constructor","__proto__","_extends","assign","target","i","arguments","length","source","key","hasOwnProperty","call","apply","this","isServer","window","noop","functionalUpdate","updater","input","isValidTimeout","value","Infinity","ensureArray","Array","isArray","difference","array1","array2","filter","x","indexOf","timeUntilStale","updatedAt","staleTime","Math","max","Date","now","parseQueryArgs","arg1","arg2","arg3","isQueryKey","queryKey","queryFn","unwrapRefs","parseFilterArgs","matchQuery","filters","query","isActive","active","exact","fetching","inactive","predicate","stale","hashFn","getQueryKeyHashFn","options","queryHash","partialMatchKey","isStale","isFetching","queryKeyHashFn","hashQueryKey","JSON","stringify","_","val","isPlainObject","keys","sort","reduce","result","a","b","partialDeepEqual","some","replaceEqualDeep","array","isSameObject","bSize","splice","aKeys","bKeys","hash","Set","len","has","o","hasObjectPrototype","ctor","prot","toString","getStatusProps","status","isLoading","isSuccess","isError","isIdle","refs","isRef","items","size","copy","logger","console","error","warn","log","getLogger","setLogger","newLogger","Subscribable","listeners","subscribe","listener","callback","push","onSubscribe","_this","onUnsubscribe","hasListeners","focusManager","removeEventListener","setDefaultEventListener","setEventListener","setup","focused","setFocused","onFocus","forEach","isFocused","document","undefined","includes","visibilityState","_window","addEventListener","onlineManager","online","setOnline","onOnline","isOnline","navigator","onLine","defaultRetryDelay","failureCount","min","isCancelable","cancel","CancelledError","revert","silent","isCancelledError","Retryer","config","cancelFn","continueFn","promiseResolve","promiseReject","cancelRetry","cancelOptions","isPaused","isResolved","isTransportCancelable","promise","Promise","outerResolve","outerReject","resolve","reject","run","promiseOrValue","fn","then","timeout","retry","delay","retryDelay","shouldRetry","onFail","setTimeout","continueResolve","onPause","onContinue","Query","defaultOptions","setOptions","observers","cache","initialState","state","getDefaultState","innerState","reactive","readonly","scheduleGc","cacheTime","setDefaultOptions","clearGcTimeout","gcTimeout","optionalRemove","clearTimeout","remove","setData","prevData","data","isDataEqual","_this$options$isDataE","structuralSharing","dispatch","type","dataUpdatedAt","setState","retryer","destroy","reset","observer","enabled","isInvalidated","getReadonlyResult","isStaleByTime","find","willFetchOnWindowFocus","refetch","willFetchOnReconnect","addObserver","notify","removeObserver","invalidate","fetch","fetchOptions","cancelRefetch","queryFnContext","pageParam","context","fetchFn","_this2","behavior","_this$options$behavio","onFetch","fetchMeta","_context$fetchOptions","meta","_context$fetchOptions2","action","reducer","onQueryUpdate","initialData","hasData","dataUpdateCount","errorUpdateCount","errorUpdatedAt","fetchFailureCount","QueryCache","queries","queriesMap","build","client","get","defaultQueryOptions","getQueryDefaults","add","queryInMap","clear","getAll","findAll","Mutation","mutationId","mutationCache","execute","restored","variables","onMutate","executeMutation","onSuccess","onSettled","onError","mutationFn","onMutationUpdate","MutationCache","mutations","mutation","defaultMutationOptions","mutationKey","getMutationDefaults","resumePausedMutations","infiniteQueryBehavior","fetchMore","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","pages","oldPageParams","pageParams","newPageParams","fetchPage","manual","param","previous","queryFnResult","page","getNextPageParam","getPreviousPageParam","finalPromise","hasNextPage","nextPageParam","hasPreviousPage","previousPageParam","QueryClient","queryCache","queryDefaults","mutationDefaults","mount","unsubscribeFocus","unsubscribeOnline","unmount","getQueryData","_this$queryCache$find","setQueryData","parsedOptions","defaultedOptions","getQueryState","_this$queryCache$find2","removeQueries","resetQueries","refetchFilters","refetchQueries","cancelQueries","promises","map","all","invalidateQueries","refetchActive","refetchInactive","throwOnError","fetchQuery","prefetchQuery","fetchInfiniteQuery","prefetchInfiniteQuery","cancelMutations","getMutationCache","getQueryCache","getDefaultOptions","setQueryDefaults","_this$queryDefaults$f","setMutationDefaults","_this$mutationDefault","_defaulted","defaultQueryObserverOptions","QueryObserver","initialDataUpdateCount","initialErrorUpdateCount","bindMethods","bind","updateQuery","currentQuery","willFetchOnMount","executeFetch","updateTimers","willLoadOnMount","willRefetchOnMount","refetchOnMount","refetchOnReconnect","refetchOnWindowFocus","willFetchOptionally","clearTimers","prevOptions","prevQuery","Error","optionalFetch","updateStaleTimeout","refetchInterval","updateRefetchInterval","getCurrentResult","currentResult","readonlyResult","getNextResult","unsubscribe","getCurrentQuery","_this3","updateResult","clearStaleTimeout","staleTimeoutId","_this4","clearRefetchInterval","refetchIntervalId","setInterval","_this5","refetchIntervalInBackground","clearInterval","willFetch","isPreviousData","isPlaceholderData","keepPreviousData","previousQueryResult","_this$previousQueryRe","select","currentResultState","_this$currentResultSt","_this$currentResult","placeholderData","isFetched","isFetchedAfterMount","isLoadingError","isRefetchError","notifyOptions","_this6","QueriesObserver","updateObservers","onUpdate","setQueries","hasIndexChange","prevObservers","newObservers","index","InfiniteQueryObserver","_QueryObserver","fetchNextPage","fetchPreviousPage","_state$data","_state$data2","MutationObserver","mutate","currentMutation","mutateOptions","symbol","Symbol","useQueryClient","queryClient","inject","QueryClientProvider","defineComponent","name","props","slots","provide","onMounted","onUnmounted","useBaseQuery","optionsFn","Observer","watchEffect","suspense","ref","newIsFetching","parseMutationArgs","replaceShallowEqualDeep"],"mappings":"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"}