{"version":3,"file":"vue-query.min.mjs","sources":["../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","../node_modules/@babel/runtime/helpers/esm/extends.js","../src/core/utils.ts","../src/core/logger.ts","../src/core/subscribable.ts","../src/core/focusManager.ts","../src/core/onlineManager.ts","../src/core/retryer.ts","../src/core/query.ts","../src/core/queryCache.ts","../src/core/mutation.ts","../src/core/mutationCache.ts","../src/core/infiniteQueryBehavior.ts","../src/core/queryClient.ts","../src/core/queryObserver.ts","../src/core/queriesObserver.ts","../src/core/infiniteQueryObserver.ts","../src/core/mutationObserver.ts","../src/use/logger.ts","../src/use/setLogger.ts","../src/use/QueryClientProvider.ts","../src/use/useIsFetching.ts","../src/use/useMutation.ts","../src/use/useBaseQuery.ts","../src/use/useQuery.ts","../src/use/useQueries.ts","../src/use/useInfiniteQuery.ts"],"sourcesContent":["export default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}","export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","import { isRef } from 'vue'\n\nimport type { Query } from './query'\nimport type {\n  MutationFunction,\n  MutationKeyWithRef,\n  MutationOptions,\n  MutationOptionsWithRef,\n  QueryFunction,\n  QueryKey,\n  QueryKeyHashFunction,\n  QueryKeyWithRef,\n  QueryOptions,\n  QueryOptionsWithRef,\n  QueryStatus,\n} from './types'\n\n// TYPES\n\nexport interface QueryFilters {\n  /**\n   * Include or exclude active queries\n   */\n  active?: boolean\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include or exclude inactive queries\n   */\n  inactive?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: QueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include or exclude fetching queries\n   */\n  fetching?: boolean\n}\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined'\n\nexport function noop(): undefined {\n  return undefined\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: any): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function ensureArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value]\n}\n\nexport function difference<T>(array1: T[], array2: T[]): T[] {\n  return array1.filter(x => array2.indexOf(x) === -1)\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function parseQueryArgs<TOptions extends QueryOptions<any, any, any>>(\n  arg1: QueryKeyWithRef | QueryOptionsWithRef<any, any, any>,\n  arg2?: QueryFunction<any> | QueryOptionsWithRef<any, any, any>,\n  arg3?: QueryOptionsWithRef<any, any, any>\n): TOptions {\n  if (!isQueryKey(arg1)) {\n    return arg1 as TOptions\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3, queryKey: arg1, queryFn: arg2 } as TOptions\n  }\n\n  return unwrapRefs({ ...arg2, queryKey: arg1 }) as TOptions\n}\n\nexport function parseMutationArgs<\n  TOptions extends MutationOptions<any, any, any, any>\n>(\n  arg1:\n    | MutationKeyWithRef\n    | MutationFunction<any, any>\n    | MutationOptionsWithRef<any, any, any, any>,\n  arg2?:\n    | MutationFunction<any, any>\n    | MutationOptionsWithRef<any, any, any, any>,\n  arg3?: MutationOptionsWithRef<any, any, any, any>\n): TOptions {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return unwrapRefs({\n        ...arg3,\n        mutationKey: arg1,\n        mutationFn: arg2,\n      }) as TOptions\n    }\n    return unwrapRefs({ ...arg2, mutationKey: arg1 }) as TOptions\n  }\n\n  if (typeof arg1 === 'function') {\n    return unwrapRefs({ ...arg2, mutationFn: arg1 }) as TOptions\n  }\n\n  return unwrapRefs({ ...arg1 }) as TOptions\n}\n\nexport function parseFilterArgs<\n  TFilters extends QueryFilters,\n  TOptions = unknown\n>(\n  arg1?: QueryKeyWithRef | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions\n): [TFilters, TOptions | undefined] {\n  return (isQueryKey(arg1)\n    ? [{ ...arg2, queryKey: unwrapRefs(arg1) }, arg3]\n    : [arg1 || {}, arg2]) as [TFilters, TOptions]\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any>\n): boolean {\n  const {\n    active,\n    exact,\n    fetching,\n    inactive,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      const hashFn = getQueryKeyHashFn(query.options)\n      if (query.queryHash !== hashFn(queryKey)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  let isActive\n\n  if (inactive === false || (active && !inactive)) {\n    isActive = true\n  } else if (active === false || (inactive && !active)) {\n    isActive = false\n  }\n\n  if (typeof isActive === 'boolean' && query.isActive() !== isActive) {\n    return false\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (typeof fetching === 'boolean' && query.isFetching() !== fetching) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function getQueryKeyHashFn(\n  options?: QueryOptions<any, any>\n): QueryKeyHashFunction {\n  return options?.queryKeyHashFn || hashQueryKey\n}\n\n/**\n * Default query keys hash function.\n */\nexport function hashQueryKey(queryKey: QueryKey): string {\n  return stableValueHash(queryKey)\n}\n\n/**\n * Hashes the value into a stable hash.\n */\nexport function stableValueHash(value: any): string {\n  return JSON.stringify(value, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(\n  a: string | unknown[],\n  b: string | unknown[]\n): boolean {\n  return partialDeepEqual(ensureArray(a), ensureArray(b))\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any) {\n  if (a === b) return a\n\n  const array = Array.isArray(a) && Array.isArray(b)\n  const isSameObject = array || (isPlainObject(a) && isPlainObject(b))\n\n  if (isSameObject) {\n    if (array) {\n      const bSize = b.length\n      // omit array keys\n      if (a.length > bSize) {\n        a.splice(bSize)\n      }\n\n      // pick array keys\n      for (let i = 0; i < bSize; i++) {\n        a[i] = replaceEqualDeep(a[i], b[i])\n      }\n    } else {\n      const aKeys = Object.keys(a)\n      const bKeys = Object.keys(b)\n      const hash = new Set(bKeys)\n\n      for (let i = 0, len = aKeys.length; i < len; i++) {\n        const key = aKeys[i]\n        if (!hash.has(key)) {\n          // omit object keys\n          delete a[key]\n        }\n      }\n\n      for (let i = 0, len = bKeys.length; i < len; i++) {\n        const key = bKeys[i]\n        // pick object keys\n        a[key] = replaceEqualDeep(a[key], b[key])\n      }\n    }\n  }\n\n  return isSameObject ? a : b\n}\n\n/**\n * it will replace any equal shallow children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceShallowEqualDeep<T>(a: unknown, b: T): T\nexport function replaceShallowEqualDeep(a: any, b: any) {\n  if (a === b) return a\n\n  const array = Array.isArray(a) && Array.isArray(b)\n  const isSameObject = array || (isPlainObject(a) && isPlainObject(b))\n\n  if (isSameObject) {\n    if (array) {\n      const bSize = b.length\n      // omit array keys\n      if (a.length > bSize) {\n        a.splice(bSize)\n      }\n\n      // pick array keys\n      for (let i = 0; i < bSize; i++) {\n        a[i] = b[i]\n      }\n    } else {\n      const aKeys = Object.keys(a)\n      const bKeys = Object.keys(b)\n      const hash = new Set(bKeys)\n\n      for (let i = 0, len = aKeys.length; i < len; i++) {\n        const key = aKeys[i]\n        if (!hash.has(key)) {\n          // omit object keys\n          delete a[key]\n        }\n      }\n\n      for (let i = 0, len = bKeys.length; i < len; i++) {\n        const key = bKeys[i]\n        // pick object keys\n        a[key] = b[key]\n      }\n    }\n  }\n\n  return isSameObject ? a : b\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function isQueryKey(value: any): value is QueryKey {\n  return typeof value === 'string' || Array.isArray(value)\n}\n\nexport function isError(value: any): value is Error {\n  return value instanceof Error\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout)\n  })\n}\n\nexport function getStatusProps<T extends QueryStatus>(status: T) {\n  return {\n    status,\n    isLoading: status === 'loading',\n    isSuccess: status === 'success',\n    isError: status === 'error',\n    isIdle: status === 'idle',\n  }\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nexport function scheduleMicrotask(callback: () => void): void {\n  Promise.resolve()\n    .then(callback)\n    .catch(error =>\n      setTimeout(() => {\n        throw error\n      })\n    )\n}\n\n/**\n * it will deeply unwrap the value of ref from ref\n */\nexport function unwrapRefs(refs: any) {\n  if (isRef(refs)) {\n    return refs.value\n  }\n\n  if (typeof refs === 'function') return refs\n\n  const array = Array.isArray(refs)\n\n  if (array || isPlainObject(refs)) {\n    const items = array ? refs : Object.keys(refs)\n    const size = items.length\n    const copy: any = array ? [] : {}\n\n    for (let i = 0; i < size; i++) {\n      const key = array ? i : items[i]\n\n      copy[key] = isRef(refs[key]) ? refs[key].value : unwrapRefs(refs[key])\n    }\n    return copy\n  }\n\n  return refs\n}\n","import { noop } from './utils'\n\n// TYPES\n\nexport interface Logger {\n  log: LogFunction\n  warn: LogFunction\n  error: LogFunction\n}\n\ntype LogFunction = (...args: any[]) => void\n\n// FUNCTIONS\n\nlet logger: Logger = console || {\n  error: noop,\n  warn: noop,\n  log: noop,\n}\n\nexport function getLogger(): Logger {\n  return logger\n}\n\nexport function setLogger(newLogger: Logger) {\n  logger = newLogger\n}\n","type Listener = () => void\n\nexport class Subscribable<TListener extends Function = Listener> {\n  protected listeners: TListener[]\n\n  constructor() {\n    this.listeners = []\n  }\n\n  subscribe(listener?: TListener): () => void {\n    const callback = listener || (() => undefined)\n\n    this.listeners.push(callback as TListener)\n\n    this.onSubscribe()\n\n    return () => {\n      this.listeners = this.listeners.filter(x => x !== callback)\n      this.onUnsubscribe()\n    }\n  }\n\n  hasListeners(): boolean {\n    return this.listeners.length > 0\n  }\n\n  protected onSubscribe(): void {\n    // Do nothing\n  }\n\n  protected onUnsubscribe(): void {\n    // Do nothing\n  }\n}\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\nclass FocusManager extends Subscribable {\n  private focused?: boolean\n  private removeEventListener?: () => void\n\n  protected onSubscribe(): void {\n    if (!this.removeEventListener) {\n      this.setDefaultEventListener()\n    }\n  }\n\n  setEventListener(\n    setup: (onFocus: () => void) => (focused?: boolean) => void\n  ): void {\n    if (this.removeEventListener) {\n      this.removeEventListener()\n    }\n    this.removeEventListener = setup((focused?: boolean) => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused)\n      } else {\n        this.onFocus()\n      }\n    })\n  }\n\n  setFocused(focused?: boolean): void {\n    this.focused = focused\n\n    if (focused) {\n      this.onFocus()\n    }\n  }\n\n  onFocus(): void {\n    this.listeners.forEach(listener => {\n      listener()\n    })\n  }\n\n  isFocused(): boolean {\n    if (typeof this.focused === 'boolean') {\n      return this.focused\n    }\n\n    // document global can be unavailable in react native\n    if (typeof document === 'undefined') {\n      return true\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(\n      document.visibilityState\n    )\n  }\n\n  private setDefaultEventListener() {\n    if (!isServer && window?.addEventListener) {\n      this.setEventListener(onFocus => {\n        // Listen to visibillitychange and focus\n        window.addEventListener('visibilitychange', onFocus, false)\n        window.addEventListener('focus', onFocus, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', onFocus)\n          window.removeEventListener('focus', onFocus)\n        }\n      })\n    }\n  }\n}\n\nexport const focusManager = new FocusManager()\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\nclass OnlineManager extends Subscribable {\n  private online?: boolean\n  private removeEventListener?: () => void\n\n  protected onSubscribe(): void {\n    if (!this.removeEventListener) {\n      this.setDefaultEventListener()\n    }\n  }\n\n  setEventListener(\n    setup: (setOnline: () => void) => (online?: boolean) => void\n  ): void {\n    if (this.removeEventListener) {\n      this.removeEventListener()\n    }\n    this.removeEventListener = setup((online?: boolean) => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online)\n      } else {\n        this.onOnline()\n      }\n    })\n  }\n\n  setOnline(online?: boolean): void {\n    this.online = online\n\n    if (online) {\n      this.onOnline()\n    }\n  }\n\n  onOnline(): void {\n    this.listeners.forEach(listener => {\n      listener()\n    })\n  }\n\n  isOnline(): boolean {\n    if (typeof this.online === 'boolean') {\n      return this.online\n    }\n\n    return navigator.onLine === undefined || navigator.onLine\n  }\n\n  private setDefaultEventListener() {\n    if (!isServer && window?.addEventListener) {\n      this.setEventListener(onOnline => {\n        // Listen to online\n        window.addEventListener('online', onOnline, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', onOnline)\n        }\n      })\n    }\n  }\n}\n\nexport const onlineManager = new OnlineManager()\n","import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { functionalUpdate, sleep } from './utils'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = unknown> {\n  fn: () => TData | Promise<TData>\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError = unknown> = (\n  failureCount: number,\n  error: TError\n) => boolean\n\nexport type RetryDelayValue = number | RetryDelayFunction\n\ntype RetryDelayFunction = (failureCount: number) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\ninterface Cancelable {\n  cancel(): void\n}\n\nexport function isCancelable(value: any): value is Cancelable {\n  return typeof value?.cancel === 'function'\n}\n\nexport interface CancelOptions {\n  revert?: boolean\n  silent?: boolean\n}\n\nexport class CancelledError {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\n// CLASS\n\nexport class Retryer<TData = unknown, TError = unknown> {\n  cancel: (options?: CancelOptions) => void\n  cancelRetry: () => void\n  continue: () => void\n  failureCount: number\n  isPaused: boolean\n  isResolved: boolean\n  isTransportCancelable: boolean\n  promise: Promise<TData>\n\n  constructor(config: RetryerConfig<TData, TError>) {\n    let cancelRetry = false\n    let cancelFn: ((options?: CancelOptions) => void) | undefined\n    let continueFn: ((value?: unknown) => void) | undefined\n    let promiseResolve: (data: TData) => void\n    let promiseReject: (error: TError) => void\n\n    this.cancel = cancelOptions => cancelFn?.(cancelOptions)\n    this.cancelRetry = () => {\n      cancelRetry = true\n    }\n    this.continue = () => continueFn?.()\n    this.failureCount = 0\n    this.isPaused = false\n    this.isResolved = false\n    this.isTransportCancelable = false\n    this.promise = new Promise<TData>((outerResolve, outerReject) => {\n      promiseResolve = outerResolve\n      promiseReject = outerReject\n    })\n\n    const resolve = (value: any) => {\n      this.isResolved = true\n      continueFn?.()\n      promiseResolve(value)\n    }\n\n    const reject = (value: any) => {\n      this.isResolved = true\n      continueFn?.()\n      promiseReject(value)\n    }\n\n    const pause = () => {\n      return new Promise(continueResolve => {\n        continueFn = continueResolve\n        this.isPaused = true\n        config.onPause?.()\n      }).then(() => {\n        continueFn = undefined\n        this.isPaused = false\n        config.onContinue?.()\n      })\n    }\n\n    // Create loop function\n    const run = () => {\n      // Do nothing if already resolved\n      if (this.isResolved) {\n        return\n      }\n\n      let promiseOrValue: any\n\n      // Execute query\n      try {\n        promiseOrValue = config.fn()\n      } catch (error) {\n        promiseOrValue = Promise.reject(error)\n      }\n\n      // Create callback to cancel this fetch\n      cancelFn = cancelOptions => {\n        reject(new CancelledError(cancelOptions))\n\n        // Cancel transport if supported\n        if (isCancelable(promiseOrValue)) {\n          try {\n            promiseOrValue.cancel()\n          } catch {}\n        }\n      }\n\n      // Check if the transport layer support cancellation\n      this.isTransportCancelable = isCancelable(promiseOrValue)\n\n      Promise.resolve(promiseOrValue)\n        .then(resolve)\n        .catch(error => {\n          // Stop if the fetch is already resolved\n          if (this.isResolved) {\n            return\n          }\n\n          // Do we need to retry the request?\n          const retry = config.retry ?? 3\n          const retryDelay = config.retryDelay ?? defaultRetryDelay\n          const delay = functionalUpdate(retryDelay, this.failureCount) || 0\n          const shouldRetry =\n            retry === true ||\n            (typeof retry === 'number' && this.failureCount < retry) ||\n            (typeof retry === 'function' && retry(this.failureCount, error))\n\n          if (cancelRetry || !shouldRetry) {\n            // We are done if the query does not need to be retried\n            reject(error)\n            return\n          }\n\n          this.failureCount++\n\n          // Notify on fail\n          config.onFail?.(this.failureCount, error)\n\n          // Delay\n          sleep(delay)\n            // Pause if the document is not visible or when the device is offline\n            .then(() => {\n              if (!focusManager.isFocused() || !onlineManager.isOnline()) {\n                return pause()\n              }\n            })\n            .then(() => {\n              if (cancelRetry) {\n                reject(error)\n              } else {\n                run()\n              }\n            })\n        })\n    }\n\n    // Start loop\n    run()\n  }\n}\n","import { reactive, readonly } from 'vue'\n\nimport {\n  Updater,\n  ensureArray,\n  functionalUpdate,\n  isValidTimeout,\n  noop,\n  replaceEqualDeep,\n  timeUntilStale,\n} from './utils'\nimport type {\n  InitialDataFunction,\n  QueryKey,\n  QueryOptions,\n  QueryStatus,\n  QueryFunctionContext,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport type { QueryObserver } from './queryObserver'\nimport { getLogger } from './logger'\nimport { Retryer, CancelOptions, isCancelledError } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<TQueryFnData, TError, TData> {\n  cache: QueryCache\n  queryKey: QueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = unknown> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchMeta: any\n  isFetching: boolean\n  isInvalidated: boolean\n  isPaused: boolean\n  status: QueryStatus\n}\n\nexport interface FetchContext<TQueryFnData, TError, TData> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  options: QueryOptions<TQueryFnData, TError, TData>\n  queryKey: QueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n> {\n  onFetch: (context: FetchContext<TQueryFnData, TError, TData>) => void\n}\n\nexport interface FetchOptions {\n  cancelRefetch?: boolean\n  meta?: any\n}\n\nexport interface SetDataOptions {\n  updatedAt?: number\n}\n\ninterface FailedAction {\n  type: 'failed'\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: any\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: QueryState<TData, TError>\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n> {\n  queryKey: QueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData>\n  initialState: QueryState<TData, TError>\n  state: QueryState<TData, TError>\n  cacheTime!: number\n\n  private innerState: QueryState<TData, TError>\n  private cache: QueryCache\n  private promise?: Promise<TData>\n  private gcTimeout?: number\n  private retryer?: Retryer<unknown, TError>\n  private observers: QueryObserver<any, any, any, any>[]\n  private defaultOptions?: QueryOptions<TQueryFnData, TError, TData>\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData>) {\n    this.defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.cache = config.cache\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.initialState = config.state || this.getDefaultState(this.options)\n    this.innerState = reactive(this.initialState) as QueryState<TData, TError>\n    this.state = readonly(this.innerState) as QueryState<TData, TError>\n    this.scheduleGc()\n  }\n\n  private setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData>\n  ): void {\n    this.options = { ...this.defaultOptions, ...options }\n\n    // Default to 5 minutes if not cache time is set\n    this.cacheTime = Math.max(\n      this.cacheTime || 0,\n      this.options.cacheTime ?? 5 * 60 * 1000\n    )\n  }\n\n  setDefaultOptions(options: QueryOptions<TQueryFnData, TError, TData>): void {\n    this.defaultOptions = options\n  }\n\n  private scheduleGc(): void {\n    this.clearGcTimeout()\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove()\n      }, this.cacheTime)\n    }\n  }\n\n  private clearGcTimeout() {\n    clearTimeout(this.gcTimeout)\n    this.gcTimeout = undefined\n  }\n\n  private optionalRemove() {\n    if (!this.observers.length && !this.state.isFetching) {\n      this.cache.remove(this)\n    }\n  }\n\n  setData(\n    updater: Updater<TData | undefined, TData>,\n    options?: SetDataOptions\n  ): TData {\n    const prevData = this.innerState.data\n\n    // Get the new data\n    let data = functionalUpdate(updater, prevData)\n\n    // Use prev data if an isDataEqual function is defined and returns `true`\n    if (this.options.isDataEqual?.(prevData, data)) {\n      data = prevData as TData\n    } else if (this.options.structuralSharing !== false) {\n      // Structurally share data between prev and new data if needed\n      data = replaceEqualDeep(prevData, data)\n    }\n\n    // Set data and mark it as cached\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n    })\n\n    return data\n  }\n\n  setState(state: QueryState<TData, TError>): void {\n    this.dispatch({ type: 'setState', state })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.promise\n    this.retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    this.clearGcTimeout()\n    this.cancel()\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some(observer => observer.options.enabled !== false)\n  }\n\n  isFetching(): boolean {\n    return this.state.isFetching\n  }\n\n  isStale(): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      this.observers.some(observer => observer.getReadonlyResult().isStale)\n    )\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n    )\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find(x => x.willFetchOnWindowFocus())\n\n    if (observer) {\n      observer.refetch()\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find(x => x.willFetchOnReconnect())\n\n    if (observer) {\n      observer.refetch()\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any>): void {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.cache.notify(this)\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any>): void {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter(x => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.retryer.isTransportCancelable) {\n            this.retryer.cancel()\n          } else {\n            this.retryer.cancelRetry()\n          }\n        }\n\n        if (this.cacheTime) {\n          this.scheduleGc()\n        } else {\n          this.cache.remove(this)\n        }\n      }\n\n      this.cache.notify(this)\n    }\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData>,\n    fetchOptions?: FetchOptions\n  ): Promise<TData> {\n    if (this.state.isFetching)\n      if (this.state.dataUpdatedAt && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({ silent: true })\n      } else if (this.promise) {\n        // Return current promise if we are already fetching\n        return this.promise\n      }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    // Create query function context\n    const queryKey = ensureArray(this.queryKey)\n    const queryFnContext: QueryFunctionContext = {\n      queryKey,\n      pageParam: undefined,\n    }\n\n    // Create fetch function\n    const fetchFn = () =>\n      this.options.queryFn\n        ? this.options.queryFn(queryFnContext)\n        : Promise.reject('Missing queryFn')\n\n    // Trigger behavior hook\n    const context: FetchContext<TQueryFnData, TError, TData> = {\n      fetchOptions,\n      options: this.options,\n      queryKey,\n      state: this.state,\n      fetchFn,\n    }\n\n    if (this.options.behavior?.onFetch) {\n      this.options.behavior?.onFetch(context)\n    }\n\n    // Set to fetching state if not already in it\n    if (\n      !this.state.isFetching ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    // Try to fetch the data\n    this.retryer = new Retryer({\n      fn: context.fetchFn,\n      onFail: () => {\n        this.dispatch({ type: 'failed' })\n      },\n      onPause: () => {\n        this.dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n    })\n\n    this.promise = this.retryer.promise\n      .then(data => this.setData(data as TData))\n      .catch(error => {\n        // Set error state if needed\n        if (!(isCancelledError(error) && error.silent)) {\n          this.dispatch({\n            type: 'error',\n            error,\n          })\n        }\n\n        // Log error\n        if (!isCancelledError(error)) {\n          getLogger().error(error)\n        }\n\n        // Propagate error\n        throw error\n      })\n      .finally(() => {\n        // Remove query after fetching if cache time is 0\n        if (this.cacheTime === 0) {\n          this.optionalRemove()\n        }\n      })\n\n    return this.promise\n  }\n\n  private dispatch(action: Action<TData, TError>): void {\n    Object.assign(this.innerState, this.reducer(this.state, action))\n\n    this.observers.forEach(observer => {\n      observer.onQueryUpdate(action)\n    })\n\n    this.cache.notify(this)\n  }\n\n  protected getDefaultState(\n    options: QueryOptions<TQueryFnData, TError, TData>\n  ): QueryState<TData, TError> {\n    const data =\n      typeof options.initialData === 'function'\n        ? (options.initialData as InitialDataFunction<TData>)()\n        : options.initialData\n\n    const hasData = typeof data !== 'undefined'\n\n    return {\n      data,\n      dataUpdateCount: 0,\n      dataUpdatedAt: hasData ? Date.now() : 0,\n      error: null,\n      errorUpdateCount: 0,\n      errorUpdatedAt: 0,\n      fetchFailureCount: 0,\n      fetchMeta: null,\n      isFetching: false,\n      isInvalidated: false,\n      isPaused: false,\n      status: hasData ? 'success' : 'idle',\n    }\n  }\n\n  protected reducer(\n    state: QueryState<TData, TError>,\n    action: Action<TData, TError>\n  ): QueryState<TData, TError> {\n    switch (action.type) {\n      case 'failed':\n        return {\n          ...state,\n          fetchFailureCount: state.fetchFailureCount + 1,\n        }\n      case 'pause':\n        return {\n          ...state,\n          isPaused: true,\n        }\n      case 'continue':\n        return {\n          ...state,\n          isPaused: false,\n        }\n      case 'fetch':\n        return {\n          ...state,\n          fetchFailureCount: 0,\n          fetchMeta: action.meta ?? null,\n          isFetching: true,\n          isPaused: false,\n          status: state.status === 'idle' ? 'loading' : state.status,\n        }\n      case 'success':\n        return {\n          ...state,\n          data: action.data,\n          dataUpdateCount: state.dataUpdateCount + 1,\n          dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n          error: null,\n          fetchFailureCount: 0,\n          isFetching: false,\n          isInvalidated: false,\n          isPaused: false,\n          status: 'success',\n        }\n      case 'error':\n        const error = action.error as unknown\n\n        if (isCancelledError(error) && error.revert) {\n          return {\n            ...state,\n            fetchFailureCount: 0,\n            isFetching: false,\n            isPaused: false,\n            status: state.status === 'loading' ? 'idle' : state.status,\n          }\n        }\n\n        return {\n          ...state,\n          error: error as TError,\n          errorUpdateCount: state.errorUpdateCount + 1,\n          errorUpdatedAt: Date.now(),\n          fetchFailureCount: state.fetchFailureCount + 1,\n          isFetching: false,\n          isPaused: false,\n          status: 'error',\n        }\n      case 'invalidate':\n        return {\n          ...state,\n          isInvalidated: true,\n        }\n      case 'setState':\n        return {\n          ...state,\n          ...action.state,\n        }\n      default:\n        return state\n    }\n  }\n}\n","import {\n  QueryFilters,\n  getQueryKeyHashFn,\n  matchQuery,\n  parseFilterArgs,\n} from './utils'\nimport { Query, QueryState } from './query'\nimport type { QueryKeyWithRef, QueryOptions } from './types'\nimport type { QueryClient } from './queryClient'\nimport { Subscribable } from './subscribable'\n\n// TYPES\n\ninterface QueryHashMap {\n  [hash: string]: Query<any, any>\n}\n\ntype QueryCacheListener = (query?: Query) => void\n\n// CLASS\n\nexport class QueryCache extends Subscribable<QueryCacheListener> {\n  private queries: Query<any, any>[]\n  private queriesMap: QueryHashMap\n\n  constructor() {\n    super()\n\n    this.queries = []\n    this.queriesMap = {}\n  }\n\n  build<TQueryFnData, TError, TData>(\n    client: QueryClient,\n    options: QueryOptions<TQueryFnData, TError, TData>,\n    state?: QueryState<TData, TError>\n  ): Query<TQueryFnData, TError, TData> {\n    const hashFn = getQueryKeyHashFn(options)\n    const queryKey = options.queryKey!\n    const queryHash = options.queryHash ?? hashFn(queryKey)\n    let query = this.get<TQueryFnData, TError, TData>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n\n  add(query: Query<any, any>): void {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query\n      this.queries.push(query)\n      this.notify(query)\n    }\n  }\n\n  remove(query: Query<any, any>): void {\n    const queryInMap = this.queriesMap[query.queryHash]\n\n    if (queryInMap) {\n      query.destroy()\n\n      this.queries = this.queries.filter(x => x !== query)\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash]\n      }\n\n      this.notify(query)\n    }\n  }\n\n  clear(): void {\n    this.queries.forEach(query => {\n      this.remove(query)\n    })\n  }\n\n  get<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    queryHash: string\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    return this.queriesMap[queryHash]\n  }\n\n  getAll(): Query[] {\n    return this.queries\n  }\n\n  find<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    arg1: QueryKeyWithRef,\n    arg2?: QueryFilters\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    return this.queries.find(query => matchQuery(filters, query))\n  }\n\n  findAll(queryKey?: QueryKeyWithRef, filters?: QueryFilters): Query[]\n  findAll(filters?: QueryFilters): Query[]\n  findAll(arg1?: QueryKeyWithRef | QueryFilters, arg2?: QueryFilters): Query[]\n  findAll(arg1?: QueryKeyWithRef | QueryFilters, arg2?: QueryFilters): Query[] {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    return filters\n      ? this.queries.filter(query => matchQuery(filters, query))\n      : this.queries\n  }\n\n  notify(query?: Query<any, any>) {\n    this.listeners.forEach(listener => {\n      listener(query)\n    })\n  }\n\n  onFocus(): void {\n    this.queries.forEach(query => {\n      query.onFocus()\n    })\n  }\n\n  onOnline(): void {\n    this.queries.forEach(query => {\n      query.onOnline()\n    })\n  }\n}\n","import type { MutationOptions, MutationStatus } from './types'\nimport type { MutationCache } from './mutationCache'\nimport type { MutationObserver } from './mutationObserver'\nimport { getLogger } from './logger'\nimport { Retryer } from './retryer'\nimport { noop } from './utils'\n\n// TYPES\n\ninterface MutationConfig<TData, TError, TVariables, TContext> {\n  mutationId: number\n  mutationCache: MutationCache\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  defaultOptions?: MutationOptions<TData, TError, TVariables, TContext>\n  state?: MutationState<TData, TError, TVariables, TContext>\n}\n\nexport interface MutationState<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n> {\n  context: TContext | undefined\n  data: TData | undefined\n  error: TError | null\n  failureCount: number\n  isPaused: boolean\n  status: MutationStatus\n  variables: TVariables | undefined\n}\n\ninterface FailedAction {\n  type: 'failed'\n}\n\ninterface LoadingAction<TVariables, TContext> {\n  type: 'loading'\n  variables?: TVariables\n  context?: TContext\n}\n\ninterface SuccessAction<TData> {\n  type: 'success'\n  data: TData\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError, TVariables, TContext> {\n  type: 'setState'\n  state: MutationState<TData, TError, TVariables, TContext>\n}\n\nexport type Action<TData, TError, TVariables, TContext> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction\n  | LoadingAction<TVariables, TContext>\n  | PauseAction\n  | SetStateAction<TData, TError, TVariables, TContext>\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Mutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n> {\n  state: MutationState<TData, TError, TVariables, TContext>\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  mutationId: number\n\n  private observers: MutationObserver<TData, TError, TVariables, TContext>[]\n  private mutationCache: MutationCache\n  private retryer?: Retryer<TData, TError>\n\n  constructor(config: MutationConfig<TData, TError, TVariables, TContext>) {\n    this.options = {\n      ...config.defaultOptions,\n      ...config.options,\n    }\n    this.mutationId = config.mutationId\n    this.mutationCache = config.mutationCache\n    this.observers = []\n    this.state = config.state || getDefaultState()\n  }\n\n  setState(state: MutationState<TData, TError, TVariables, TContext>): void {\n    this.dispatch({ type: 'setState', state })\n  }\n\n  addObserver(observer: MutationObserver<any, any, any, any>): void {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer)\n    }\n  }\n\n  removeObserver(observer: MutationObserver<any, any, any, any>): void {\n    this.observers = this.observers.filter(x => x !== observer)\n  }\n\n  cancel(): Promise<void> {\n    if (this.retryer) {\n      this.retryer.cancel()\n      return this.retryer.promise.then(noop).catch(noop)\n    }\n    return Promise.resolve()\n  }\n\n  continue(): Promise<TData> {\n    if (this.retryer) {\n      this.retryer.continue()\n      return this.retryer.promise\n    }\n    return this.execute()\n  }\n\n  execute(): Promise<TData> {\n    let data: TData\n\n    const restored = this.state.status === 'loading'\n\n    let promise = Promise.resolve()\n\n    if (!restored) {\n      this.dispatch({ type: 'loading', variables: this.options.variables! })\n      promise = promise\n        .then(() => this.options.onMutate?.(this.state.variables!))\n        .then(context => {\n          if (context !== this.state.context) {\n            this.dispatch({\n              type: 'loading',\n              context,\n              variables: this.state.variables,\n            })\n          }\n        })\n    }\n\n    return promise\n      .then(() => this.executeMutation())\n      .then(result => {\n        data = result\n      })\n      .then(() =>\n        this.options.onSuccess?.(\n          data,\n          this.state.variables!,\n          this.state.context!\n        )\n      )\n      .then(() =>\n        this.options.onSettled?.(\n          data,\n          null,\n          this.state.variables!,\n          this.state.context\n        )\n      )\n      .then(() => {\n        this.dispatch({ type: 'success', data })\n        return data\n      })\n      .catch(error => {\n        getLogger().error(error)\n        return Promise.resolve()\n          .then(() =>\n            this.options.onError?.(\n              error,\n              this.state.variables!,\n              this.state.context\n            )\n          )\n          .then(() =>\n            this.options.onSettled?.(\n              undefined,\n              error,\n              this.state.variables!,\n              this.state.context\n            )\n          )\n          .then(() => {\n            this.dispatch({ type: 'error', error })\n            throw error\n          })\n      })\n  }\n\n  private executeMutation(): Promise<TData> {\n    this.retryer = new Retryer({\n      fn: () => {\n        if (!this.options.mutationFn) {\n          return Promise.reject('No mutationFn found')\n        }\n        return this.options.mutationFn(this.state.variables!)\n      },\n      onFail: () => {\n        this.dispatch({ type: 'failed' })\n      },\n      onPause: () => {\n        this.dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.dispatch({ type: 'continue' })\n      },\n      retry: this.options.retry ?? 0,\n      retryDelay: this.options.retryDelay,\n    })\n\n    return this.retryer.promise\n  }\n\n  private dispatch(action: Action<TData, TError, TVariables, TContext>): void {\n    this.state = reducer(this.state, action)\n\n    this.observers.forEach(observer => {\n      observer.onMutationUpdate(action)\n    })\n    this.mutationCache.notify(this)\n  }\n}\n\nexport function getDefaultState<\n  TData,\n  TError,\n  TVariables,\n  TContext\n>(): MutationState<TData, TError, TVariables, TContext> {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined,\n  }\n}\n\nfunction reducer<TData, TError, TVariables, TContext>(\n  state: MutationState<TData, TError, TVariables, TContext>,\n  action: Action<TData, TError, TVariables, TContext>\n): MutationState<TData, TError, TVariables, TContext> {\n  switch (action.type) {\n    case 'failed':\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n      }\n    case 'pause':\n      return {\n        ...state,\n        isPaused: true,\n      }\n    case 'continue':\n      return {\n        ...state,\n        isPaused: false,\n      }\n    case 'loading':\n      return {\n        ...state,\n        context: action.context,\n        data: undefined,\n        error: null,\n        isPaused: false,\n        status: 'loading',\n        variables: action.variables,\n      }\n    case 'success':\n      return {\n        ...state,\n        data: action.data,\n        error: null,\n        status: 'success',\n        isPaused: false,\n      }\n    case 'error':\n      return {\n        ...state,\n        data: undefined,\n        error: action.error,\n        failureCount: state.failureCount + 1,\n        isPaused: false,\n        status: 'error',\n      }\n    case 'setState':\n      return {\n        ...state,\n        ...action.state,\n      }\n    default:\n      return state\n  }\n}\n","import type { MutationOptions } from './types'\nimport type { QueryClient } from './queryClient'\nimport { Mutation, MutationState } from './mutation'\nimport { noop } from './utils'\nimport { Subscribable } from './subscribable'\n\n// TYPES\n\ntype MutationCacheListener = (mutation?: Mutation) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  private mutations: Mutation<any, any, any, any>[]\n  private mutationId: number\n\n  constructor() {\n    super()\n    this.mutations = []\n    this.mutationId = 0\n  }\n\n  build<TData, TError, TVariables, TContext>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n    state?: MutationState<TData, TError, TVariables, TContext>\n  ): Mutation<TData, TError, TVariables, TContext> {\n    const mutation = new Mutation({\n      mutationCache: this,\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey\n        ? client.getMutationDefaults(options.mutationKey)\n        : undefined,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    this.mutations.push(mutation)\n    this.notify(mutation)\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    this.mutations = this.mutations.filter(x => x !== mutation)\n    mutation.cancel()\n    this.notify(mutation)\n  }\n\n  clear(): void {\n    this.mutations.forEach(mutation => {\n      this.remove(mutation)\n    })\n  }\n\n  getAll(): Mutation[] {\n    return this.mutations\n  }\n\n  notify(mutation?: Mutation<any, any, any, any>) {\n    this.listeners.forEach(listener => {\n      listener(mutation)\n    })\n  }\n\n  onFocus(): void {\n    this.resumePausedMutations()\n  }\n\n  onOnline(): void {\n    this.resumePausedMutations()\n  }\n\n  resumePausedMutations(): Promise<void> {\n    const pausedMutations = this.mutations.filter(x => x.state.isPaused)\n\n    return pausedMutations.reduce(\n      (promise, mutation) =>\n        promise.then(() => mutation.continue().catch(noop)),\n      Promise.resolve()\n    )\n  }\n}\n","import type { QueryBehavior } from './query'\nimport { isCancelable } from './retryer'\nimport type { InfiniteData, QueryFunctionContext, QueryOptions } from './types'\n\nexport function infiniteQueryBehavior<\n  TQueryFnData,\n  TError,\n  TData\n>(): QueryBehavior<TQueryFnData, TError, InfiniteData<TData>> {\n  return {\n    onFetch: context => {\n      context.fetchFn = () => {\n        const fetchMore = context.fetchOptions?.meta?.fetchMore\n        const pageParam = fetchMore?.pageParam\n        const isFetchingNextPage = fetchMore?.direction === 'forward'\n        const isFetchingPreviousPage = fetchMore?.direction === 'backward'\n        const oldPages = context.state.data?.pages || []\n        const oldPageParams = context.state.data?.pageParams || []\n        let newPageParams = oldPageParams\n\n        // Get query function\n        const queryFn =\n          context.options.queryFn || (() => Promise.reject('Missing queryFn'))\n\n        // Create function to fetch a page\n        const fetchPage = (\n          pages: unknown[],\n          manual?: boolean,\n          param?: unknown,\n          previous?: boolean\n        ): Promise<unknown[]> => {\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages)\n          }\n\n          const queryFnContext: QueryFunctionContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n          }\n\n          let cancelFn: undefined | (() => any)\n          const queryFnResult = queryFn(queryFnContext)\n          if ((queryFnResult as any).cancel) {\n            cancelFn = (queryFnResult as any).cancel\n          }\n\n          const promise = Promise.resolve(queryFnResult).then(page => {\n            newPageParams = previous\n              ? [param, ...newPageParams]\n              : [...newPageParams, param]\n            return previous ? [page, ...pages] : [...pages, page]\n          })\n\n          if (cancelFn) {\n            const promiseAsAny = promise as any\n            promiseAsAny.cancel = cancelFn\n          }\n\n          return promise\n        }\n\n        let promise\n\n        // Fetch first page?\n        if (!oldPages.length) {\n          promise = fetchPage([])\n        }\n\n        // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getNextPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param)\n        }\n\n        // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getPreviousPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param, true)\n        }\n\n        // Refetch pages\n        else {\n          newPageParams = []\n\n          const manual = typeof context.options.getNextPageParam === 'undefined'\n\n          // Fetch first page\n          promise = fetchPage([], manual, oldPageParams[0])\n\n          // Fetch remaining pages\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then(pages => {\n              const param = manual\n                ? oldPageParams[i]\n                : getNextPageParam(context.options, pages)\n              return fetchPage(pages, manual, param)\n            })\n          }\n        }\n\n        const finalPromise = promise.then(pages => ({\n          pages,\n          pageParams: newPageParams,\n        }))\n\n        if (isCancelable(promise)) {\n          const finalPromiseAsAny = finalPromise as any\n          finalPromiseAsAny.cancel = promise.cancel\n        }\n\n        return finalPromise\n      }\n    },\n  }\n}\n\nexport function getNextPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[]\n): unknown | undefined {\n  return options.getNextPageParam?.(pages[pages.length - 1], pages)\n}\n\nexport function getPreviousPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[]\n): unknown | undefined {\n  return options.getPreviousPageParam?.(pages[0], pages)\n}\n\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasNextPage(\n  options: QueryOptions<any, any>,\n  pages?: unknown\n): boolean | undefined {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages)\n    return (\n      typeof nextPageParam !== 'undefined' &&\n      nextPageParam !== null &&\n      nextPageParam !== false\n    )\n  }\n}\n\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasPreviousPage(\n  options: QueryOptions<any, any>,\n  pages?: unknown\n): boolean | undefined {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages)\n    return (\n      typeof previousPageParam !== 'undefined' &&\n      previousPageParam !== null &&\n      previousPageParam !== false\n    )\n  }\n}\n","import {\n  QueryFilters,\n  Updater,\n  hashQueryKey,\n  noop,\n  parseFilterArgs,\n  parseQueryArgs,\n  partialMatchKey,\n} from './utils'\nimport type {\n  DefaultOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryKeyWithRef,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  ResetOptions,\n} from './types'\nimport type { QueryState, SetDataOptions } from './query'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { CancelOptions } from './retryer'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\n\n// TYPES\n\ninterface QueryClientConfig {\n  queryCache?: QueryCache\n  mutationCache?: MutationCache\n  defaultOptions?: DefaultOptions\n}\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: QueryOptions<any, any, any>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  private queryCache: QueryCache\n  private mutationCache: MutationCache\n  private defaultOptions: DefaultOptions\n  private queryDefaults: QueryDefaults[]\n  private mutationDefaults: MutationDefaults[]\n  private unsubscribeFocus?: () => void\n  private unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.queryCache = config.queryCache || new QueryCache()\n    this.mutationCache = config.mutationCache || new MutationCache()\n    this.defaultOptions = config.defaultOptions || {}\n    this.queryDefaults = []\n    this.mutationDefaults = []\n  }\n\n  mount(): void {\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused() && onlineManager.isOnline()) {\n        this.mutationCache.onFocus()\n        this.queryCache.onFocus()\n      }\n    })\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (focusManager.isFocused() && onlineManager.isOnline()) {\n        this.mutationCache.onOnline()\n        this.queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.unsubscribeFocus?.()\n    this.unsubscribeOnline?.()\n  }\n\n  isFetching(filters?: QueryFilters): number\n  isFetching(queryKey?: QueryKeyWithRef, filters?: QueryFilters): number\n  isFetching(\n    arg1?: QueryKeyWithRef | QueryFilters,\n    arg2?: QueryFilters\n  ): number {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    filters.fetching = true\n    return this.queryCache.findAll(filters).length\n  }\n\n  getQueryData<TData = unknown>(\n    queryKey: QueryKey,\n    filters?: QueryFilters\n  ): TData | undefined {\n    return this.queryCache.find<TData>(queryKey, filters)?.state.data\n  }\n\n  setQueryData<TData>(\n    queryKey: QueryKeyWithRef,\n    updater: Updater<TData | undefined, TData>,\n    options?: SetDataOptions\n  ): TData {\n    const parsedOptions = parseQueryArgs(queryKey)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n    return this.queryCache\n      .build(this, defaultedOptions)\n      .setData(updater, options)\n  }\n\n  getQueryState<TData = unknown, TError = undefined>(\n    queryKey: QueryKeyWithRef,\n    filters?: QueryFilters\n  ): QueryState<TData, TError> | undefined {\n    return this.queryCache.find<TData, TError>(queryKey, filters)?.state\n  }\n\n  removeQueries(filters?: QueryFilters): void\n  removeQueries(queryKey?: QueryKeyWithRef, filters?: QueryFilters): void\n  removeQueries(\n    arg1?: QueryKeyWithRef | QueryFilters,\n    arg2?: QueryFilters\n  ): void {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    const queryCache = this.queryCache\n    queryCache.findAll(filters).forEach(query => {\n      queryCache.remove(query)\n    })\n  }\n\n  resetQueries(filters?: QueryFilters, options?: ResetOptions): Promise<void>\n  resetQueries(\n    queryKey?: QueryKeyWithRef,\n    filters?: QueryFilters,\n    options?: ResetOptions\n  ): Promise<void>\n  resetQueries(\n    arg1?: QueryKeyWithRef | QueryFilters,\n    arg2?: QueryFilters | ResetOptions,\n    arg3?: ResetOptions\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n    const queryCache = this.queryCache\n\n    const refetchFilters: QueryFilters = {\n      ...filters,\n      active: true,\n    }\n\n    queryCache.findAll(filters).forEach(query => {\n      query.reset()\n    })\n    return this.refetchQueries(refetchFilters, options)\n  }\n\n  cancelQueries(filters?: QueryFilters, options?: CancelOptions): Promise<void>\n  cancelQueries(\n    queryKey?: QueryKeyWithRef,\n    filters?: QueryFilters,\n    options?: CancelOptions\n  ): Promise<void>\n  cancelQueries(\n    arg1?: QueryKeyWithRef | QueryFilters,\n    arg2?: QueryFilters | CancelOptions,\n    arg3?: CancelOptions\n  ): Promise<void> {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3)\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true\n    }\n\n    const promises = this.queryCache\n      .findAll(filters)\n      .map(query => query.cancel(cancelOptions))\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries(\n    filters?: InvalidateQueryFilters,\n    options?: InvalidateOptions\n  ): Promise<void>\n  invalidateQueries(\n    queryKey?: QueryKeyWithRef,\n    filters?: InvalidateQueryFilters,\n    options?: InvalidateOptions\n  ): Promise<void>\n  invalidateQueries(\n    arg1?: QueryKeyWithRef | InvalidateQueryFilters,\n    arg2?: InvalidateQueryFilters | InvalidateOptions,\n    arg3?: InvalidateOptions\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    const refetchFilters: QueryFilters = {\n      ...filters,\n      active: filters.refetchActive ?? true,\n      inactive: filters.refetchInactive ?? false,\n    }\n\n    this.queryCache.findAll(filters).forEach(query => {\n      query.invalidate()\n    })\n    return this.refetchQueries(refetchFilters, options)\n  }\n\n  refetchQueries(\n    filters?: QueryFilters,\n    options?: RefetchOptions\n  ): Promise<void>\n  refetchQueries(\n    queryKey?: QueryKeyWithRef,\n    filters?: QueryFilters,\n    options?: RefetchOptions\n  ): Promise<void>\n  refetchQueries(\n    arg1?: QueryKeyWithRef | QueryFilters,\n    arg2?: QueryFilters | RefetchOptions,\n    arg3?: RefetchOptions\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    const promises = this.queryCache\n      .findAll(filters)\n      .map(query => query.fetch())\n\n    let promise = Promise.all(promises).then(noop)\n\n    if (!options?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  fetchQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    options: FetchQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<TData>\n  fetchQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    queryKey: QueryKeyWithRef,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<TData>\n  fetchQuery<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    queryKey: QueryKeyWithRef,\n    queryFn: QueryFunction<TQueryFnData>,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<TData>\n  fetchQuery<TQueryFnData, TError, TData = TQueryFnData>(\n    arg1: QueryKeyWithRef | FetchQueryOptions<TQueryFnData, TError, TData>,\n    arg2?:\n      | QueryFunction<TQueryFnData>\n      | FetchQueryOptions<TQueryFnData, TError, TData>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<TData> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions)\n\n    // @ts-ignore\n    return query.isStaleByTime(defaultedOptions.staleTime)\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery(options: FetchQueryOptions): Promise<void>\n  prefetchQuery(queryKey: QueryKey, options?: FetchQueryOptions): Promise<void>\n  prefetchQuery(\n    queryKey: QueryKey,\n    queryFn: QueryFunction,\n    options?: FetchQueryOptions\n  ): Promise<void>\n  prefetchQuery(\n    arg1: QueryKey | FetchQueryOptions,\n    arg2?: QueryFunction | FetchQueryOptions,\n    arg3?: FetchQueryOptions\n  ): Promise<void> {\n    return this.fetchQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData\n  >(\n    queryKey: QueryKey,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData\n  >(\n    queryKey: QueryKey,\n    queryFn: QueryFunction<TQueryFnData>,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<TQueryFnData, TError, TData = TQueryFnData>(\n    arg1: QueryKey | FetchInfiniteQueryOptions<TQueryFnData, TError, TData>,\n    arg2?:\n      | QueryFunction<TQueryFnData>\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData>,\n    arg3?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData>\n  ): Promise<InfiniteData<TData>> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    parsedOptions.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData\n    >()\n    return this.fetchQuery(parsedOptions)\n  }\n\n  prefetchInfiniteQuery(options: FetchInfiniteQueryOptions): Promise<void>\n  prefetchInfiniteQuery(\n    queryKey: QueryKeyWithRef,\n    options?: FetchInfiniteQueryOptions\n  ): Promise<void>\n  prefetchInfiniteQuery(\n    queryKey: QueryKeyWithRef,\n    queryFn: QueryFunction,\n    options?: FetchInfiniteQueryOptions\n  ): Promise<void>\n  prefetchInfiniteQuery(\n    arg1: QueryKeyWithRef | FetchInfiniteQueryOptions,\n    arg2?: QueryFunction | FetchInfiniteQueryOptions,\n    arg3?: FetchInfiniteQueryOptions\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  cancelMutations(): Promise<void> {\n    const promises = this.mutationCache\n      .getAll()\n      .map(mutation => mutation.cancel())\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  resumePausedMutations(): Promise<void> {\n    return this.getMutationCache().resumePausedMutations()\n  }\n\n  executeMutation<\n    TData = unknown,\n    TError = unknown,\n    TVariables = void,\n    TContext = unknown\n  >(\n    options: MutationOptions<TData, TError, TVariables, TContext>\n  ): Promise<TData> {\n    return this.mutationCache.build(this, options).execute()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.mutationCache\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.defaultOptions = options\n  }\n\n  setQueryDefaults(\n    queryKey: QueryKey,\n    options: QueryObserverOptions<any, any, any, any>\n  ): void {\n    const result = this.queryDefaults.find(\n      x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey)\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.queryDefaults.push({ queryKey, defaultOptions: options })\n    }\n  }\n\n  getQueryDefaults(\n    queryKey?: QueryKey\n  ): QueryObserverOptions<any, any, any, any> | undefined {\n    return queryKey\n      ? this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey))\n          ?.defaultOptions\n      : undefined\n  }\n\n  setMutationDefaults(\n    mutationKey: MutationKey,\n    options: MutationObserverOptions<any, any, any, any>\n  ): void {\n    const result = this.mutationDefaults.find(\n      x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey)\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.mutationDefaults.push({ mutationKey, defaultOptions: options })\n    }\n  }\n\n  getMutationDefaults(\n    mutationKey?: MutationKey\n  ): MutationObserverOptions<any, any, any, any> | undefined {\n    return mutationKey\n      ? this.mutationDefaults.find(x =>\n          partialMatchKey(mutationKey, x.mutationKey)\n        )?.defaultOptions\n      : undefined\n  }\n\n  defaultQueryOptions<T extends QueryOptions<any, any, any>>(options?: T): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options?.queryKey),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  defaultQueryObserverOptions<\n    T extends QueryObserverOptions<any, any, any, any>\n  >(options?: T): T {\n    return this.defaultQueryOptions(options)\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options?.mutationKey),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.queryCache.clear()\n    this.mutationCache.clear()\n  }\n}\n","import { reactive, readonly } from 'vue'\n\nimport {\n  getStatusProps,\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceEqualDeep,\n  timeUntilStale,\n} from './utils'\nimport type {\n  PlaceholderDataFunction,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n  ResultOptions,\n} from './types'\nimport type { Query, QueryState, Action, FetchOptions } from './query'\nimport type { QueryClient } from './queryClient'\nimport { focusManager } from './focusManager'\nimport { Subscribable } from './subscribable'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>\n) => void\n\ninterface NotifyOptions {\n  cache?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\nexport interface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  options: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>\n\n  private client: QueryClient\n  private currentQuery!: Query<TQueryFnData, TError, TQueryData>\n  private currentResult!: QueryObserverResult<TData, TError>\n  private readonlyResult!: QueryObserverResult<TData, TError>\n  private currentResultState?: QueryState<TQueryData, TError>\n  private previousQueryResult?: QueryObserverResult<TData, TError>\n  private initialDataUpdateCount: number\n  private initialErrorUpdateCount: number\n  private staleTimeoutId?: number\n  private refetchIntervalId?: number\n\n  constructor(\n    client: QueryClient,\n    options: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>\n  ) {\n    super()\n\n    this.client = client\n    this.options = options\n    this.initialDataUpdateCount = 0\n    this.initialErrorUpdateCount = 0\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.remove = this.remove.bind(this)\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.length === 1) {\n      this.updateQuery()\n\n      this.currentQuery.addObserver(this)\n\n      if (this.willFetchOnMount()) {\n        this.executeFetch()\n      }\n\n      this.updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.destroy()\n    }\n  }\n\n  willLoadOnMount(): boolean {\n    return (\n      this.options.enabled !== false && !this.currentQuery.state.dataUpdatedAt\n    )\n  }\n\n  willRefetchOnMount(): boolean {\n    return (\n      this.options.enabled !== false &&\n      this.currentQuery.state.dataUpdatedAt > 0 &&\n      (this.options.refetchOnMount === 'always' ||\n        (this.options.refetchOnMount !== false && this.isStale()))\n    )\n  }\n\n  willFetchOnMount(): boolean {\n    return this.willLoadOnMount() || this.willRefetchOnMount()\n  }\n\n  willFetchOnReconnect(): boolean {\n    return (\n      this.options.enabled !== false &&\n      (this.options.refetchOnReconnect === 'always' ||\n        (this.options.refetchOnReconnect !== false && this.isStale()))\n    )\n  }\n\n  willFetchOnWindowFocus(): boolean {\n    return (\n      this.options.enabled !== false &&\n      (this.options.refetchOnWindowFocus === 'always' ||\n        (this.options.refetchOnWindowFocus !== false && this.isStale()))\n    )\n  }\n\n  private willFetchOptionally(): boolean {\n    return this.options.enabled !== false && this.isStale()\n  }\n\n  private isStale(): boolean {\n    return this.currentQuery.isStaleByTime(this.options.staleTime)\n  }\n\n  destroy(): void {\n    this.listeners = []\n    this.clearTimers()\n    this.currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options?: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>\n  ): void {\n    const prevOptions = { ...this.options }\n    const prevQuery = this.currentQuery\n\n    this.options = this.client.defaultQueryObserverOptions(options)\n\n    if (\n      typeof this.options.enabled !== 'undefined' &&\n      typeof this.options.enabled !== 'boolean'\n    ) {\n      throw new Error('Expected enabled to be a boolean')\n    }\n\n    // Keep previous query key if the user does not supply one\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey\n    }\n\n    this.updateQuery()\n\n    // Take no further actions if there are no subscribers\n    if (!this.listeners.length) {\n      return\n    }\n\n    // If we subscribed to a new query, optionally fetch and update refetch\n    if (this.currentQuery !== prevQuery) {\n      this.optionalFetch()\n      this.updateTimers()\n      return\n    }\n\n    // Optionally fetch if the query became enabled\n    if (this.options.enabled !== false && prevOptions.enabled === false) {\n      this.optionalFetch()\n    }\n\n    // Update stale interval if needed\n    if (\n      this.options.enabled !== prevOptions.enabled ||\n      this.options.staleTime !== prevOptions.staleTime\n    ) {\n      this.updateStaleTimeout()\n    }\n\n    // Update refetch interval if needed\n    if (\n      this.options.enabled !== prevOptions.enabled ||\n      this.options.refetchInterval !== prevOptions.refetchInterval\n    ) {\n      this.updateRefetchInterval()\n    }\n  }\n\n  protected getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.currentResult\n  }\n\n  getReadonlyResult(): QueryObserverResult<TData, TError> {\n    return (\n      this.readonlyResult ||\n      (this.readonlyResult = readonly(\n        this.currentResult\n      ) as QueryObserverResult<TData, TError>)\n    )\n  }\n\n  getNextResult(\n    options?: ResultOptions\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return new Promise((resolve, reject) => {\n      const unsubscribe = this.subscribe(result => {\n        if (!result.isFetching) {\n          unsubscribe()\n          if (result.isError && options?.throwOnError) {\n            reject(result.error)\n          } else {\n            resolve(result)\n          }\n        }\n      })\n    })\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData> {\n    return this.currentQuery\n  }\n\n  remove(): void {\n    this.client.getQueryCache().remove(this.currentQuery)\n  }\n\n  refetch(\n    options?: RefetchOptions\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.fetch(options)\n  }\n\n  protected fetch(\n    fetchOptions?: ObserverFetchOptions\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.executeFetch(fetchOptions).then(() => {\n      this.updateResult()\n      return this.currentResult\n    })\n  }\n\n  private optionalFetch(): void {\n    if (this.willFetchOptionally()) {\n      this.executeFetch()\n    }\n  }\n\n  private executeFetch(\n    fetchOptions?: ObserverFetchOptions\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData>,\n      fetchOptions\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  private updateStaleTimeout(): void {\n    this.clearStaleTimeout()\n\n    if (\n      isServer ||\n      this.currentResult.isStale ||\n      !isValidTimeout(this.options.staleTime)\n    ) {\n      return\n    }\n\n    const time = timeUntilStale(\n      this.currentResult.dataUpdatedAt,\n      this.options.staleTime\n    )\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult()\n        this.notify({\n          cache: true,\n        })\n      }\n    }, timeout)\n  }\n\n  private updateRefetchInterval(): void {\n    this.clearRefetchInterval()\n\n    if (\n      isServer ||\n      this.options.enabled === false ||\n      !isValidTimeout(this.options.refetchInterval)\n    ) {\n      return\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.executeFetch()\n      }\n    }, this.options.refetchInterval)\n  }\n\n  private updateTimers(): void {\n    this.updateStaleTimeout()\n    this.updateRefetchInterval()\n  }\n\n  private clearTimers(): void {\n    this.clearStaleTimeout()\n    this.clearRefetchInterval()\n  }\n\n  private clearStaleTimeout(): void {\n    clearTimeout(this.staleTimeoutId)\n    this.staleTimeoutId = undefined\n  }\n\n  private clearRefetchInterval(): void {\n    clearInterval(this.refetchIntervalId)\n    this.refetchIntervalId = undefined\n  }\n\n  protected updateResult(willFetch?: boolean) {\n    const { state } = this.currentQuery\n    let { isFetching, status } = state\n    let isPreviousData = false\n    let isPlaceholderData = false\n    let data: TData | undefined\n    let dataUpdatedAt = state.dataUpdatedAt\n\n    // Optimistically set status to loading if we will start fetching\n    if (willFetch) {\n      isFetching = true\n      if (status === 'idle') {\n        status = 'loading'\n      }\n    }\n\n    // Keep previous data if needed\n    if (\n      this.options.keepPreviousData &&\n      !state.dataUpdateCount &&\n      this.previousQueryResult?.isSuccess\n    ) {\n      data = this.previousQueryResult.data\n      dataUpdatedAt = this.previousQueryResult.dataUpdatedAt\n      status = this.previousQueryResult.status\n      isPreviousData = true\n    }\n    // Select data if needed\n    else if (this.options.select && typeof state.data !== 'undefined') {\n      // Use the previous select result if the query data did not change\n      if (this.currentResult && state.data === this.currentResultState?.data) {\n        data = this.currentResult.data\n      } else {\n        data = this.options.select(state.data)\n        if (this.options.structuralSharing !== false) {\n          data = replaceEqualDeep(this.currentResult?.data, data)\n        }\n      }\n    }\n    // Use query data\n    else {\n      data = (state.data as unknown) as TData\n    }\n\n    // Show placeholder data if needed\n    if (\n      typeof this.options.placeholderData !== 'undefined' &&\n      typeof data === 'undefined' &&\n      status === 'loading'\n    ) {\n      const placeholderData =\n        typeof this.options.placeholderData === 'function'\n          ? (this.options.placeholderData as PlaceholderDataFunction<TData>)()\n          : this.options.placeholderData\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success'\n        data = placeholderData\n        isPlaceholderData = true\n      }\n    }\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      ...getStatusProps(status),\n      data,\n      dataUpdatedAt,\n      error: state.error,\n      errorUpdatedAt: state.errorUpdateCount,\n      failureCount: state.fetchFailureCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        state.dataUpdateCount > this.initialDataUpdateCount ||\n        state.errorUpdateCount > this.initialErrorUpdateCount,\n      isFetching,\n      isLoadingError: status === 'error' && state.dataUpdatedAt === 0,\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: status === 'error' && state.dataUpdatedAt !== 0,\n      isStale: this.isStale(),\n      refetch: this.refetch,\n      remove: this.remove,\n    }\n\n    if (this.currentResult) {\n      Object.assign(this.currentResult, result)\n    } else {\n      this.currentResult = reactive(result) as QueryObserverResult<\n        TData,\n        TError\n      >\n    }\n  }\n\n  private updateQuery(): void {\n    const prevQuery = this.currentQuery\n\n    const query = this.client\n      .getQueryCache()\n      .build(\n        this.client,\n        this.options as QueryOptions<TQueryFnData, TError, TQueryData>\n      )\n\n    if (query === prevQuery) {\n      return\n    }\n\n    this.previousQueryResult = { ...this.currentResult }\n    this.currentQuery = query\n    this.initialDataUpdateCount = query.state.dataUpdateCount\n    this.initialErrorUpdateCount = query.state.errorUpdateCount\n\n    const willFetch = prevQuery\n      ? this.willFetchOptionally()\n      : this.willFetchOnMount()\n\n    this.updateResult(willFetch)\n\n    if (!this.hasListeners()) {\n      return\n    }\n\n    prevQuery?.removeObserver(this)\n    this.currentQuery.addObserver(this)\n\n    this.notify({})\n  }\n\n  onQueryUpdate(action: Action<TData, TError>): void {\n    this.updateResult()\n    // Update timers\n    this.updateTimers()\n\n    // Determine which callbacks to trigger\n    const notifyOptions: NotifyOptions = {}\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true\n    }\n\n    this.notify(notifyOptions)\n  }\n\n  private notify(notifyOptions: NotifyOptions): void {\n    // First trigger the configuration callbacks\n    if (notifyOptions.onSuccess) {\n      this.options.onSuccess?.(this.readonlyResult.data!)\n      this.options.onSettled?.(this.readonlyResult.data!, null)\n    } else if (notifyOptions.onError) {\n      this.options.onError?.(this.readonlyResult.error!)\n      this.options.onSettled?.(undefined, this.readonlyResult.error!)\n    }\n\n    // Then trigger the listeners\n    this.listeners.forEach(listener => {\n      listener(this.readonlyResult)\n    })\n\n    // Then the cache listeners\n    if (notifyOptions.cache) {\n      this.client.getQueryCache().notify(this.currentQuery)\n    }\n  }\n}\n","import { difference, getQueryKeyHashFn } from './utils'\nimport type { QueryObserverOptions, QueryObserverResult } from './types'\nimport type { QueryClient } from './queryClient'\nimport { QueryObserver } from './queryObserver'\nimport { Subscribable } from './subscribable'\n\ntype QueriesObserverListener = (result: QueryObserverResult[]) => void\n\nexport class QueriesObserver extends Subscribable<QueriesObserverListener> {\n  private client: QueryClient\n  private result!: QueryObserverResult[]\n  private queries: QueryObserverOptions[]\n  private observers: QueryObserver[]\n\n  constructor(client: QueryClient, queries?: QueryObserverOptions[]) {\n    super()\n\n    this.client = client\n    this.queries = queries || []\n    this.observers = []\n\n    // Subscribe to queries\n    this.updateObservers()\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.length === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result)\n        })\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.destroy()\n    }\n  }\n\n  destroy(): void {\n    this.listeners = []\n    this.observers.forEach(observer => {\n      observer.destroy()\n    })\n  }\n\n  setQueries(queries: QueryObserverOptions[]): void {\n    this.queries = queries\n    this.updateObservers()\n  }\n\n  getCurrentResult(): QueryObserverResult[] {\n    return this.result\n  }\n\n  private updateObservers(): void {\n    let hasIndexChange = false\n\n    const prevObservers = this.observers\n    const newObservers = this.queries.map((options, i) => {\n      let observer: QueryObserver | undefined = prevObservers[i]\n\n      const defaultedOptions = this.client.defaultQueryObserverOptions(options)\n      const hashFn = getQueryKeyHashFn(defaultedOptions)\n      defaultedOptions.queryHash = hashFn(defaultedOptions.queryKey!)\n\n      if (\n        !observer ||\n        observer.getCurrentQuery().queryHash !== defaultedOptions.queryHash\n      ) {\n        hasIndexChange = true\n        observer = prevObservers.find(\n          x => x.getCurrentQuery().queryHash === defaultedOptions.queryHash\n        )\n      }\n\n      if (observer) {\n        observer.setOptions(defaultedOptions)\n        return observer\n      }\n\n      return new QueryObserver(this.client, defaultedOptions)\n    })\n\n    if (prevObservers.length === newObservers.length && !hasIndexChange) {\n      return\n    }\n\n    this.observers = newObservers\n    this.result = newObservers.map(observer => observer.getReadonlyResult())\n\n    if (!this.listeners.length) {\n      return\n    }\n\n    difference(prevObservers, newObservers).forEach(observer => {\n      observer.destroy()\n    })\n\n    difference(newObservers, prevObservers).forEach(observer => {\n      observer.subscribe(result => {\n        this.onUpdate(observer, result)\n      })\n    })\n\n    this.notify()\n  }\n\n  private onUpdate(observer: QueryObserver, result: QueryObserverResult): void {\n    const index = this.observers.indexOf(observer)\n    if (index !== -1) {\n      this.result[index] = result\n      this.notify()\n    }\n  }\n\n  private notify(): void {\n    this.listeners.forEach(listener => {\n      listener(this.result)\n    })\n  }\n}\n","import type {\n  FetchNextPageOptions,\n  FetchPreviousPageOptions,\n  InfiniteData,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport { ObserverFetchOptions, QueryObserver } from './queryObserver'\nimport {\n  hasNextPage,\n  hasPreviousPage,\n  infiniteQueryBehavior,\n} from './infiniteQueryBehavior'\n\ntype InfiniteQueryObserverListener<TData, TError> = (\n  result: InfiniteQueryObserverResult<TData, TError>\n) => void\n\nexport class InfiniteQueryObserver<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData\n> extends QueryObserver<\n  TQueryFnData,\n  TError,\n  InfiniteData<TData>,\n  InfiniteData<TQueryData>\n> {\n  // Type override\n  subscribe!: (\n    listener?: InfiniteQueryObserverListener<TData, TError>\n  ) => () => void\n\n  // Type override\n  getCurrentResult!: () => InfiniteQueryObserverResult<TData, TError>\n\n  // Type override\n  protected fetch!: (\n    fetchOptions?: ObserverFetchOptions\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(\n    client: QueryClient,\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData\n    >\n  ) {\n    super(client, options)\n  }\n\n  protected bindMethods(): void {\n    super.bindMethods()\n    this.fetchNextPage = this.fetchNextPage.bind(this)\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this)\n  }\n\n  setOptions(\n    options?: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData\n    >\n  ): void {\n    super.setOptions({\n      ...options,\n      behavior: infiniteQueryBehavior<TQueryFnData, TError, TData>(),\n    })\n  }\n\n  fetchNextPage(\n    options?: FetchNextPageOptions\n  ): Promise<InfiniteQueryObserverResult<TData, TError>> {\n    return this.fetch({\n      cancelRefetch: true,\n      throwOnError: options?.throwOnError,\n      meta: {\n        fetchMore: { direction: 'forward', pageParam: options?.pageParam },\n      },\n    })\n  }\n\n  fetchPreviousPage(\n    options?: FetchPreviousPageOptions\n  ): Promise<InfiniteQueryObserverResult<TData, TError>> {\n    return this.fetch({\n      cancelRefetch: true,\n      throwOnError: options?.throwOnError,\n      meta: {\n        fetchMore: { direction: 'backward', pageParam: options?.pageParam },\n      },\n    })\n  }\n\n  protected updateResult(willFetch?: boolean) {\n    const { state } = this.getCurrentQuery()\n    super.updateResult(willFetch)\n\n    Object.assign(super.getCurrentResult(), {\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(this.options, state.data?.pages),\n      hasPreviousPage: hasPreviousPage(this.options, state.data?.pages),\n      isFetchingNextPage:\n        state.isFetching && state.fetchMeta?.fetchMore?.direction === 'forward',\n      isFetchingPreviousPage:\n        state.isFetching &&\n        state.fetchMeta?.fetchMore?.direction === 'backward',\n    })\n  }\n}\n","import { Action, getDefaultState, Mutation } from './mutation'\nimport type { QueryClient } from './queryClient'\nimport { Subscribable } from './subscribable'\nimport type {\n  MutateOptions,\n  MutationObserverResult,\n  MutationObserverOptions,\n} from './types'\nimport { getStatusProps } from './utils'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TContext> = (\n  result: MutationObserverResult<TData, TError, TVariables, TContext>\n) => void\n\ninterface NotifyOptions {\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TContext>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TContext>\n\n  private client: QueryClient\n  private currentResult!: MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >\n  private currentMutation?: Mutation<TData, TError, TVariables, TContext>\n  private mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>\n  ) {\n    super()\n\n    this.client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options?: MutationObserverOptions<TData, TError, TVariables, TContext>\n  ) {\n    this.options = this.client.defaultMutationOptions(options)\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void {\n    this.updateResult()\n\n    // Determine which callbacks to trigger\n    const notifyOptions: NotifyOptions = {\n      listeners: true,\n    }\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true\n    }\n\n    this.notify(notifyOptions)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  > {\n    return this.currentResult\n  }\n\n  reset(): void {\n    this.currentMutation = undefined\n    this.updateResult()\n    this.notify({ listeners: true })\n  }\n\n  mutate(\n    variables?: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>\n  ): Promise<TData> {\n    this.mutateOptions = options\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this)\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, {\n      ...this.options,\n      variables: variables ?? this.options.variables,\n    })\n\n    this.currentMutation.addObserver(this)\n\n    return this.currentMutation.execute()\n  }\n\n  private updateResult(): void {\n    const state = this.currentMutation\n      ? this.currentMutation.state\n      : getDefaultState<TData, TError, TVariables, TContext>()\n\n    this.currentResult = {\n      ...state,\n      ...getStatusProps(state.status),\n      mutate: this.mutate,\n      reset: this.reset,\n    }\n  }\n\n  private notify(options: NotifyOptions) {\n    // First trigger the mutate callbacks\n    if (this.mutateOptions) {\n      if (options.onSuccess) {\n        this.mutateOptions.onSuccess?.(\n          this.currentResult.data!,\n          this.currentResult.variables!,\n          this.currentResult.context!\n        )\n        this.mutateOptions.onSettled?.(\n          this.currentResult.data!,\n          null,\n          this.currentResult.variables!,\n          this.currentResult.context\n        )\n      } else if (options.onError) {\n        this.mutateOptions.onError?.(\n          this.currentResult.error!,\n          this.currentResult.variables!,\n          this.currentResult.context\n        )\n        this.mutateOptions.onSettled?.(\n          undefined,\n          this.currentResult.error,\n          this.currentResult.variables!,\n          this.currentResult.context\n        )\n      }\n    }\n\n    // Then trigger the listeners\n    if (options.listeners) {\n      this.listeners.forEach(listener => {\n        listener(this.currentResult)\n      })\n    }\n  }\n}\n","import type { Logger } from '../core/logger'\n\nexport const logger: Logger = console\n","import { setLogger } from '../core'\nimport { logger } from './logger'\n\nif (logger) {\n  setLogger(logger)\n}\n","import { defineComponent, inject, onMounted, onUnmounted, provide } from 'vue'\n\nimport { QueryClient } from '../core'\n\nconst symbol = Symbol('QueryClientProvider')\n\nexport const useQueryClient = () => {\n  const queryClient = inject<QueryClient | undefined>(symbol, undefined)\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return queryClient\n}\n\nexport interface QueryClientProviderProps {\n  client: QueryClient\n}\n\nexport const QueryClientProvider = defineComponent<QueryClientProviderProps>({\n  name: 'QueryClientProvider',\n  setup(props, { slots }) {\n    const { client } = props\n\n    provide(symbol, client)\n    onMounted(() => {\n      client.mount()\n    })\n    onUnmounted(() => {\n      client.unmount()\n    })\n\n    return slots.default?.()\n  },\n})\n","import { onMounted, onUnmounted, ref, Ref } from 'vue'\n\nimport { QueryKeyWithRef } from '../core/types'\nimport { parseFilterArgs, QueryFilters } from '../core/utils'\nimport { useQueryClient } from './QueryClientProvider'\n\nexport function useIsFetching(filters?: QueryFilters): Ref<number>\nexport function useIsFetching(\n  queryKey?: QueryKeyWithRef,\n  filters?: QueryFilters\n): Ref<number>\nexport function useIsFetching(\n  arg1?: QueryKeyWithRef | QueryFilters,\n  arg2?: QueryFilters\n): Ref<number> {\n  const queryClient = useQueryClient()\n  const [filters] = parseFilterArgs(arg1, arg2)\n\n  const isFetching = ref<number>(queryClient.isFetching(filters))\n\n  let unsubscribe: () => void\n  onMounted(() => {\n    unsubscribe = queryClient.getQueryCache().subscribe(() => {\n      const newIsFetching = queryClient.isFetching(filters)\n      isFetching.value = newIsFetching\n    })\n  })\n  onUnmounted(() => {\n    unsubscribe?.()\n  })\n\n  return isFetching\n}\n","import { reactive, readonly, watchEffect, onMounted, onUnmounted } from 'vue'\n\nimport { noop, parseMutationArgs } from '../core/utils'\nimport { MutationObserver } from '../core/mutationObserver'\nimport { useQueryClient } from './QueryClientProvider'\nimport {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport {\n  MutationFunction,\n  MutationKey,\n  MutationObserverResult,\n} from '../core/types'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n>(\n  mutationFn: MutationFunction<TData, TVariables>,\n  options?: UseMutationOptions<TData, TError, TVariables, TContext>\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n>(\n  mutationKey: MutationKey,\n  options?: UseMutationOptions<TData, TError, TVariables, TContext>\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n>(\n  mutationKey: MutationKey,\n  mutationFn?: MutationFunction<TData, TVariables>,\n  options?: UseMutationOptions<TData, TError, TVariables, TContext>\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown\n>(\n  arg1:\n    | MutationKey\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg2?:\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg3?: UseMutationOptions<TData, TError, TVariables, TContext>\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const queryClient = useQueryClient()\n\n  // Create mutation observer\n  let observer: MutationObserver<TData, TError, TVariables, TContext>\n\n  // Create mutation currentResult\n  let currentResult!: UseMutationResult<TData, TError, TVariables, TContext>\n\n  watchEffect(() => {\n    const options = parseMutationArgs(arg1, arg2, arg3)\n\n    if (observer) {\n      // Update options\n      if (observer.hasListeners()) {\n        observer.setOptions(options)\n      } else {\n        // init observer & currentResult\n        observer = new MutationObserver(queryClient, options)\n\n        const mutate: UseMutateFunction<TData, TError, TVariables, TContext> = (\n          variables,\n          mutateOptions\n        ) => {\n          observer.mutate(variables, mutateOptions).catch(noop)\n        }\n\n        currentResult = reactive({\n          ...observer.getCurrentResult(),\n          mutate,\n          mutateAsync: observer.getCurrentResult().mutate,\n        }) as UseMutationResult<TData, TError, TVariables, TContext>\n      }\n    }\n  })\n\n  let unsubscribe: () => void\n  onMounted(() => {\n    // Subscribe to the observer\n    unsubscribe = observer.subscribe(\n      (result: MutationObserverResult<TData, TError, TVariables, TContext>) => {\n        // Check if the component is still mounted\n        if (observer.hasListeners()) {\n          Object.assign(currentResult, result)\n        }\n      }\n    )\n  })\n  onUnmounted(() => {\n    unsubscribe?.()\n  })\n\n  return readonly(currentResult) as UseMutationResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >\n}\n","import { onMounted, onUnmounted, watchEffect } from 'vue'\n\nimport { QueryObserver } from '../core/queryObserver'\nimport { useQueryClient } from './QueryClientProvider'\nimport { UseBaseQueryOptions } from './types'\n\nexport function useBaseQuery<TQueryFnData, TError, TData, TQueryData>(\n  optionsFn: () => UseBaseQueryOptions<TQueryFnData, TError, TData, TQueryData>,\n  Observer: typeof QueryObserver\n) {\n  const queryClient = useQueryClient()\n\n  let observer!: QueryObserver<any, any, any, any>\n\n  watchEffect(() => {\n    const defaultedOptions = queryClient.defaultQueryObserverOptions(\n      optionsFn()\n    )\n\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly re-mounting after suspense\n    if (\n      defaultedOptions.suspense &&\n      typeof defaultedOptions.staleTime !== 'number'\n    ) {\n      defaultedOptions.staleTime = 1000\n    }\n\n    if (observer) {\n      // Update options\n      if (observer.hasListeners()) {\n        observer.setOptions(defaultedOptions)\n      }\n    } else {\n      // Create query observer\n      observer = new Observer(queryClient, defaultedOptions)\n    }\n  })\n\n  const currentResult = observer.getReadonlyResult()\n\n  // Subscribe to the observer\n  let unsubscribe: () => void\n  onMounted(() => {\n    unsubscribe = observer.subscribe()\n  })\n  onUnmounted(() => {\n    unsubscribe?.()\n  })\n\n  // Handle suspense\n  if (observer.options.suspense && currentResult.isLoading) {\n    const unsubscribe = observer.subscribe()\n    throw observer.refetch().finally(unsubscribe)\n  }\n\n  return currentResult\n}\n","import { QueryObserver } from '../core'\nimport { QueryFunction, QueryKeyWithRef } from '../core/types'\nimport { parseQueryArgs } from '../core/utils'\nimport { UseQueryOptionsWithRef, UseQueryResult } from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n>(\n  options: UseQueryOptionsWithRef<TQueryFnData, TError, TData>\n): UseQueryResult<TData, TError>\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n>(\n  queryKey: QueryKeyWithRef,\n  options?: UseQueryOptionsWithRef<TQueryFnData, TError, TData>\n): UseQueryResult<TData, TError>\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n>(\n  queryKey: QueryKeyWithRef,\n  queryFn: QueryFunction<TQueryFnData>,\n  options?: UseQueryOptionsWithRef<TQueryFnData, TError, TData>\n): UseQueryResult<TData, TError>\nexport function useQuery<TQueryFnData, TError, TData = TQueryFnData>(\n  arg1: QueryKeyWithRef | UseQueryOptionsWithRef<TQueryFnData, TError, TData>,\n  arg2?:\n    | QueryFunction<TQueryFnData>\n    | UseQueryOptionsWithRef<TQueryFnData, TError, TData>,\n  arg3?: UseQueryOptionsWithRef<TQueryFnData, TError, TData>\n): UseQueryResult<TData, TError> {\n  return useBaseQuery(() => parseQueryArgs(arg1, arg2, arg3), QueryObserver)\n}\n","import { reactive, readonly, watchEffect, onMounted, onUnmounted } from 'vue'\n\nimport { QueriesObserver } from '../core/queriesObserver'\nimport { useQueryClient } from './QueryClientProvider'\nimport { UseQueryOptions, UseQueryResult } from './types'\nimport { replaceShallowEqualDeep } from '../core/utils'\n\nexport function useQueries(queries: UseQueryOptions[]): UseQueryResult[] {\n  const queryClient = useQueryClient()\n\n  // Create queries observer\n  let observer!: QueriesObserver\n\n  watchEffect(() => {\n    if (observer) {\n      // Update queries\n      if (observer.hasListeners()) {\n        observer.setQueries(queries)\n      }\n    } else {\n      observer = new QueriesObserver(queryClient, queries)\n    }\n  })\n\n  const currentResult = reactive(observer.getCurrentResult())\n\n  let unsubscribe: () => void\n  // Subscribe to the observer\n  onMounted(() => {\n    unsubscribe = observer.subscribe(result => {\n      replaceShallowEqualDeep(currentResult, result)\n    })\n  })\n  onUnmounted(() => {\n    unsubscribe?.()\n  })\n\n  return readonly(currentResult) as UseQueryResult[]\n}\n","import { QueryObserver } from '../core'\nimport { InfiniteQueryObserver } from '../core/infiniteQueryObserver'\nimport { QueryFunction, QueryKeyWithRef } from '../core/types'\nimport { parseQueryArgs } from '../core/utils'\nimport { UseInfiniteQueryOptionsWithRef, UseInfiniteQueryResult } from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\n\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n>(\n  options: UseInfiniteQueryOptionsWithRef<TQueryFnData, TError, TData>\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n>(\n  queryKey: QueryKeyWithRef,\n  options?: UseInfiniteQueryOptionsWithRef<TQueryFnData, TError, TData>\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData\n>(\n  queryKey: QueryKeyWithRef,\n  queryFn: QueryFunction<TQueryFnData>,\n  options?: UseInfiniteQueryOptionsWithRef<TQueryFnData, TError, TData>\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<TQueryFnData, TError, TData = TQueryFnData>(\n  arg1:\n    | QueryKeyWithRef\n    | UseInfiniteQueryOptionsWithRef<TQueryFnData, TError, TData>,\n  arg2?:\n    | QueryFunction<TQueryFnData>\n    | UseInfiniteQueryOptionsWithRef<TQueryFnData, TError, TData>,\n  arg3?: UseInfiniteQueryOptionsWithRef<TQueryFnData, TError, TData>\n): UseInfiniteQueryResult<TData, TError> {\n  return useBaseQuery(\n    () => parseQueryArgs(arg1, arg2, arg3),\n    InfiniteQueryObserver as typeof QueryObserver\n  ) as UseInfiniteQueryResult<TData, TError>\n}\n"],"names":["_inheritsLoose","subClass","superClass","prototype","Object","create","constructor","__proto__","_extends","assign","target","i","arguments","length","source","key","hasOwnProperty","call","apply","this","isServer","window","noop","functionalUpdate","updater","input","isValidTimeout","value","Infinity","ensureArray","Array","isArray","difference","array1","array2","filter","x","indexOf","timeUntilStale","updatedAt","staleTime","Math","max","Date","now","parseQueryArgs","arg1","arg2","arg3","isQueryKey","queryKey","queryFn","unwrapRefs","parseFilterArgs","matchQuery","filters","query","isActive","active","exact","fetching","inactive","predicate","stale","hashFn","getQueryKeyHashFn","options","queryHash","partialMatchKey","isStale","isFetching","queryKeyHashFn","hashQueryKey","JSON","stringify","_","val","isPlainObject","keys","sort","reduce","result","a","b","partialDeepEqual","some","replaceEqualDeep","array","isSameObject","bSize","splice","aKeys","bKeys","hash","Set","len","has","o","hasObjectPrototype","ctor","prot","toString","isError","Error","getStatusProps","status","isLoading","isSuccess","isIdle","refs","isRef","items","size","copy","logger","console","error","warn","log","getLogger","setLogger","newLogger","Subscribable","listeners","subscribe","listener","callback","push","onSubscribe","_this","onUnsubscribe","hasListeners","focusManager","removeEventListener","setDefaultEventListener","setEventListener","setup","focused","setFocused","onFocus","forEach","isFocused","document","undefined","includes","visibilityState","_window","addEventListener","onlineManager","online","setOnline","onOnline","isOnline","navigator","onLine","defaultRetryDelay","failureCount","min","isCancelable","cancel","CancelledError","revert","silent","isCancelledError","Retryer","config","cancelFn","continueFn","promiseResolve","promiseReject","cancelRetry","cancelOptions","isPaused","isResolved","isTransportCancelable","promise","Promise","outerResolve","outerReject","resolve","reject","run","promiseOrValue","fn","then","timeout","retry","delay","retryDelay","shouldRetry","onFail","setTimeout","continueResolve","onPause","onContinue","Query","defaultOptions","setOptions","observers","cache","initialState","state","getDefaultState","innerState","reactive","readonly","scheduleGc","cacheTime","setDefaultOptions","clearGcTimeout","gcTimeout","optionalRemove","clearTimeout","remove","setData","prevData","data","isDataEqual","_this$options$isDataE","structuralSharing","dispatch","type","dataUpdatedAt","setState","retryer","destroy","reset","observer","enabled","isInvalidated","getReadonlyResult","isStaleByTime","find","willFetchOnWindowFocus","refetch","willFetchOnReconnect","addObserver","notify","removeObserver","invalidate","fetch","fetchOptions","cancelRefetch","queryFnContext","pageParam","context","fetchFn","_this2","behavior","_this$options$behavio","onFetch","fetchMeta","_context$fetchOptions","meta","_context$fetchOptions2","action","reducer","onQueryUpdate","initialData","hasData","dataUpdateCount","errorUpdateCount","errorUpdatedAt","fetchFailureCount","QueryCache","queries","queriesMap","build","client","get","defaultQueryOptions","getQueryDefaults","add","queryInMap","clear","getAll","findAll","Mutation","mutationId","mutationCache","execute","restored","variables","onMutate","executeMutation","onSuccess","onSettled","onError","mutationFn","onMutationUpdate","MutationCache","mutations","mutation","defaultMutationOptions","mutationKey","getMutationDefaults","resumePausedMutations","infiniteQueryBehavior","fetchMore","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","pages","oldPageParams","pageParams","newPageParams","fetchPage","manual","param","previous","queryFnResult","page","getNextPageParam","getPreviousPageParam","finalPromise","hasNextPage","nextPageParam","hasPreviousPage","previousPageParam","QueryClient","queryCache","queryDefaults","mutationDefaults","mount","unsubscribeFocus","unsubscribeOnline","unmount","getQueryData","_this$queryCache$find","setQueryData","parsedOptions","defaultedOptions","getQueryState","_this$queryCache$find2","removeQueries","resetQueries","refetchFilters","refetchQueries","cancelQueries","promises","map","all","invalidateQueries","refetchActive","refetchInactive","throwOnError","fetchQuery","prefetchQuery","fetchInfiniteQuery","prefetchInfiniteQuery","cancelMutations","getMutationCache","getQueryCache","getDefaultOptions","setQueryDefaults","_this$queryDefaults$f","setMutationDefaults","_this$mutationDefault","_defaulted","defaultQueryObserverOptions","QueryObserver","initialDataUpdateCount","initialErrorUpdateCount","bindMethods","bind","updateQuery","currentQuery","willFetchOnMount","executeFetch","updateTimers","willLoadOnMount","willRefetchOnMount","refetchOnMount","refetchOnReconnect","refetchOnWindowFocus","willFetchOptionally","clearTimers","prevOptions","prevQuery","optionalFetch","updateStaleTimeout","refetchInterval","updateRefetchInterval","getCurrentResult","currentResult","readonlyResult","getNextResult","unsubscribe","getCurrentQuery","_this3","updateResult","clearStaleTimeout","staleTimeoutId","_this4","clearRefetchInterval","refetchIntervalId","setInterval","_this5","refetchIntervalInBackground","clearInterval","willFetch","isPreviousData","isPlaceholderData","keepPreviousData","previousQueryResult","_this$previousQueryRe","select","currentResultState","_this$currentResultSt","_this$currentResult","placeholderData","isFetched","isFetchedAfterMount","isLoadingError","isRefetchError","notifyOptions","_this6","QueriesObserver","updateObservers","onUpdate","setQueries","hasIndexChange","prevObservers","newObservers","index","InfiniteQueryObserver","_QueryObserver","fetchNextPage","fetchPreviousPage","_state$data","_state$data2","MutationObserver","mutate","currentMutation","mutateOptions","symbol","Symbol","useQueryClient","queryClient","inject","QueryClientProvider","defineComponent","name","props","slots","provide","onMounted","onUnmounted","useIsFetching","ref","newIsFetching","useMutation","watchEffect","parseMutationArgs","useBaseQuery","optionsFn","Observer","suspense","useQuery","useQueries","replaceShallowEqualDeep","useInfiniteQuery"],"mappings":"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"}