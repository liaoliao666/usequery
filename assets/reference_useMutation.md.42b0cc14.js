import{l as e,f as t,G as n}from"./framework.dc3bd9a4.js";const o='{"title":"useMutation","description":"","frontmatter":{"id":"useMutation","title":"useMutation"},"relativePath":"reference/useMutation.md","lastUpdated":1610690709865}',i={},a=n('<div class="language-js"><pre><code><span class="token keyword">const</span> <span class="token punctuation">{</span>\n  data<span class="token punctuation">,</span>\n  error<span class="token punctuation">,</span>\n  isError<span class="token punctuation">,</span>\n  isIdle<span class="token punctuation">,</span>\n  isLoading<span class="token punctuation">,</span>\n  isPaused<span class="token punctuation">,</span>\n  isSuccess<span class="token punctuation">,</span>\n  mutate<span class="token punctuation">,</span>\n  mutateAsync<span class="token punctuation">,</span>\n  reset<span class="token punctuation">,</span>\n  status<span class="token punctuation">,</span>\n<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useMutation</span><span class="token punctuation">(</span>mutationFn<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  onError<span class="token punctuation">,</span>\n  onMutate<span class="token punctuation">,</span>\n  onSettled<span class="token punctuation">,</span>\n  onSuccess<span class="token punctuation">,</span>\n  useErrorBoundary<span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token function">mutate</span><span class="token punctuation">(</span>variables<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  onError<span class="token punctuation">,</span>\n  onSettled<span class="token punctuation">,</span>\n  onSuccess<span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p><strong>Options</strong></p><ul><li><code>mutationFn: (variables: TVariables) =&gt; Promise&lt;TData&gt;</code><ul><li><strong>Required</strong></li><li>A function that performs an asynchronous task and returns a promise.</li><li><code>variables</code> is an object that <code>mutate</code> will pass to your <code>mutationFn</code></li></ul></li><li><code>mutationKey: string</code><ul><li>Optional</li><li>A mutation key can be set to inherit defaults set with <code>queryClient.setMutationDefaults</code> or to identify the mutation in the devtools.</li></ul></li><li><code>onMutate: (variables: TVariables) =&gt; Promise&lt;TContext | void&gt; | TContext | void</code><ul><li>Optional</li><li>This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive</li><li>Useful to perform optimistic updates to a resource in hopes that the mutation succeeds</li><li>The value returned from this function will be passed to both the <code>onError</code> and <code>onSettled</code> functions in the event of a mutation failure and can be useful for rolling back optimistic updates.</li></ul></li><li><code>onSuccess: (data: TData, variables: TVariables, context?: TContext) =&gt; Promise&lt;void&gt; | void</code><ul><li>Optional</li><li>This function will fire when the mutation is successful and will be passed the mutation&#39;s result.</li><li>If a promise is returned, it will be awaited and resolved before proceeding</li></ul></li><li><code>onError: (err: TError, variables: TVariables, context?: TContext) =&gt; Promise&lt;void&gt; | void</code><ul><li>Optional</li><li>This function will fire if the mutation encounters an error and will be passed the error.</li><li>If a promise is returned, it will be awaited and resolved before proceeding</li></ul></li><li><code>onSettled: (data: TData, error: TError, variables: TVariables, context?: TContext) =&gt; Promise&lt;void&gt; | void</code><ul><li>Optional</li><li>This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error</li><li>If a promise is returned, it will be awaited and resolved before proceeding</li></ul></li><li><code>retry: boolean | number | (failureCount: number, error: TError) =&gt; boolean</code><ul><li>If <code>false</code>, failed mutations will not retry by default.</li><li>If <code>true</code>, failed mutations will retry infinitely.</li><li>If set to an <code>number</code>, e.g. <code>3</code>, failed mutations will retry until the failed mutations count meets that number.</li></ul></li><li><code>retryDelay: (retryAttempt: number) =&gt; number</code><ul><li>This function receives a <code>retryAttempt</code> integer and returns the delay to apply before the next attempt in milliseconds.</li><li>A function like <code>attempt =&gt; Math.min(attempt &gt; 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)</code> applies exponential backoff.</li><li>A function like <code>attempt =&gt; attempt * 1000</code> applies linear backoff.</li></ul></li><li><code>useErrorBoundary</code><ul><li>Defaults to the global query config&#39;s <code>useErrorBoundary</code> value, which is <code>false</code></li><li>Set this to true if you want mutation errors to be thrown in the render phase and propagate to the nearest error boundary</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>mutate: (variables: TVariables, { onSuccess, onSettled, onError }) =&gt; void</code><ul><li>The mutation function you can call with variables to trigger the mutation and optionally override options passed to <code>useMutation</code>.</li><li><code>variables: TVariables</code><ul><li>Optional</li><li>The variables object to pass to the <code>mutationFn</code>.</li></ul></li><li>Remaining options extend the same options described above in the <code>useMutation</code> hook.</li></ul></li><li><code>mutateAsync: (variables: TVariables, { onSuccess, onSettled, onError }) =&gt; Promise&lt;TData&gt;</code><ul><li>Similar to <code>mutate</code> but returns a promise which can be awaited.</li></ul></li><li><code>status: string</code><ul><li>Will be: <ul><li><code>idle</code> initial status prior to the mutation function executing.</li><li><code>loading</code> if the mutation is currently executing.</li><li><code>error</code> if the last mutation attempt resulted in an error.</li><li><code>success</code> if the last mutation attempt was successful.</li></ul></li></ul></li><li><code>isIdle</code>, <code>isLoading</code>, <code>isSuccess</code>, <code>isError</code>: boolean variables derived from <code>status</code></li><li><code>data: undefined | unknown</code><ul><li>Defaults to <code>undefined</code></li><li>The last successfully resolved data for the query.</li></ul></li><li><code>error: null | TError</code><ul><li>The error object for the query, if an error was encountered.</li></ul></li><li><code>reset: () =&gt; void</code><ul><li>A function to clean the mutation internal state (i.e., it resets the mutation to its initial state).</li></ul></li></ul>',5);i.render=function(n,o,i,s,l,r){return e(),t("div",null,[a])};export default i;export{o as __pageData};
