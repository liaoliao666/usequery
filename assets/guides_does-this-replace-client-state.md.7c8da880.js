import{l as e,f as t,G as a}from"./framework.dc3bd9a4.js";const s='{"title":"Does Vu Query replace Redux, MobX or other global state managers?","description":"","frontmatter":{"id":"does-this-replace-client-state","title":"Does Vu Query replace Redux, MobX or other global state managers?"},"headers":[{"level":2,"title":"A Contrived Example","slug":"a-contrived-example"}],"relativePath":"guides/does-this-replace-client-state.md","lastUpdated":1611415935073}',o={},n=a('<p>Well, let&#39;s start with a few important items:</p><ul><li>Vu Query is a <strong>server-state</strong> library, responsible for managing asynchronous operations between your server and client</li><li>Redux, MobX, Zustand, etc. are <strong>client-state</strong> libraries that <em>can be used to store asynchronous data, albeit inefficiently when compared to a tool like Vu Query</em></li></ul><p>With those points in mind, the short answer is that Vu Query <strong>replaces the boilerplate code and related wiring used to manage cache data in your client-state and replaces it with just a few lines of code.</strong></p><p>For a vast majority of applications, the truly <strong>globally accessible client state</strong> that is left over after migrating all of your async code to Vu Query is usually very tiny.</p><blockquote><p>There are still some circumstances where an application might indeed have a massive amount of synchronous client-only state (like a visual designer or music production application), in which case, you will probably still want a client state manager. In this situation it&#39;s important to note that <strong>Vu Query is not a replacement for local/client state management</strong>. However, you can use Vu Query along side most client state managers with zero issues.</p></blockquote><h2 id="a-contrived-example"><a class="header-anchor" href="#a-contrived-example" aria-hidden="true">#</a> A Contrived Example</h2><p>Here we have some &quot;global&quot; state being managed by a global state library:</p><div class="language-js"><pre><code><span class="token keyword">const</span> globalState <span class="token operator">=</span> <span class="token punctuation">{</span>\n  projects<span class="token punctuation">,</span>\n  teams<span class="token punctuation">,</span>\n  tasks<span class="token punctuation">,</span>\n  users<span class="token punctuation">,</span>\n  themeMode<span class="token punctuation">,</span>\n  sidebarStatus<span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>Currently, the global state manager is caching 4 types of server-state: <code>projects</code>, <code>teams</code>, <code>tasks</code>, and <code>users</code>. If we were to move these server-state assets to Vu Query, our remaining global state would look more like this:</p><div class="language-js"><pre><code><span class="token keyword">const</span> globalState <span class="token operator">=</span> <span class="token punctuation">{</span>\n  themeMode<span class="token punctuation">,</span>\n  sidebarStatus<span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>This also means that with a few hook calls to <code>useQuery</code> and <code>useMutation</code>, we also get to remove any boilerplate code that use to manage our server state eg.</p><ul><li>Connectors</li><li>Action Creators</li><li>Middlewares</li><li>Reducers</li><li>Loading/Error/Result states</li><li>Contexts</li></ul><p>With all of those things removed, you may ask yourself, <strong>&quot;Is it worth it to keep using our client state manager for this tiny global state?&quot;</strong></p><p><strong>And that&#39;s up to you!</strong></p><p>But Vu Query&#39;s role is clear. It removes asynchronous wiring and boilerplate from your application and replaces it with just a few lines of code.</p><p>What are you waiting for, give it a go already!</p>',16);o.render=function(a,s,o,r,i,l){return e(),t("div",null,[n])};export default o;export{s as __pageData};
