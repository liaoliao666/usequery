import{l as n,f as s,G as a}from"./framework.dc3bd9a4.js";const e='{"title":"SSR","description":"","frontmatter":{"id":"ssr","title":"SSR"},"headers":[{"level":2,"title":"Using Next.js","slug":"using-next-js"},{"level":3,"title":"Using initialData","slug":"using-initialdata"},{"level":3,"title":"Using Hydration","slug":"using-hydration"},{"level":2,"title":"Using Other Frameworks or Custom SSR Frameworks","slug":"using-other-frameworks-or-custom-ssr-frameworks"},{"level":3,"title":"On the Server","slug":"on-the-server"},{"level":3,"title":"Client","slug":"client"},{"level":2,"title":"Tips, Tricks and Caveats","slug":"tips-tricks-and-caveats"},{"level":3,"title":"Only successful queries are included in dehydration","slug":"only-successful-queries-are-included-in-dehydration"},{"level":3,"title":"Staleness is measured from when the query was fetched on the server","slug":"staleness-is-measured-from-when-the-query-was-fetched-on-the-server"}],"relativePath":"guides/ssr.md","lastUpdated":1610601521825}',t={},o=a('<p>Vu Query supports two ways of prefetching data on the server and passing that to the queryClient.</p><ul><li>Prefetch the data yourself and pass it in as <code>initialData</code><ul><li>Quick to set up for simple cases</li><li>Has some caveats</li></ul></li><li>Prefetch the query on the server, dehydrate the cache and rehydrate it on the client <ul><li>Requires slightly more setup up front</li></ul></li></ul><h2 id="using-next-js"><a class="header-anchor" href="#using-next-js" aria-hidden="true">#</a> Using Next.js</h2><p>The exact implementation of these mechanisms may vary from platform to platform, but we recommend starting with Next.js which supports <a href="https://nextjs.org/docs/basic-features/data-fetching" target="_blank" rel="noopener noreferrer">2 forms of pre-rendering</a>:</p><ul><li>Static Generation (SSG)</li><li>Server-side Rendering (SSR)</li></ul><p>Vu Query supports both of these forms of pre-rendering regardless of what platform you may be using</p><h3 id="using-initialdata"><a class="header-anchor" href="#using-initialdata" aria-hidden="true">#</a> Using <code>initialData</code></h3><p>Together with Next.js&#39;s <a href="https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation" target="_blank" rel="noopener noreferrer"><code>getStaticProps</code></a> or <a href="https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering" target="_blank" rel="noopener noreferrer"><code>getServerSideProps</code></a>, you can pass the data you fetch in either method to <code>useQuery</code>&#39;s&#39; <code>initialData</code> option. From Vu Query&#39;s perspective, these integrate in the same way, <code>getStaticProps</code> is shown below:</p><div class="language-js"><pre><code><span class="token keyword">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getStaticProps</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> posts <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getPosts</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span> props<span class="token operator">:</span> <span class="token punctuation">{</span> posts <span class="token punctuation">}</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">Posts</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token punctuation">{</span> data <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useQuery</span><span class="token punctuation">(</span><span class="token string">&#39;posts&#39;</span><span class="token punctuation">,</span> getPosts<span class="token punctuation">,</span> <span class="token punctuation">{</span> initialData<span class="token operator">:</span> props<span class="token punctuation">.</span>posts <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>The setup is minimal and this can be a quick solution for some cases, but there are a <strong>few tradeoffs to consider</strong> when compared to the full approach:</p><ul><li>If you are calling <code>useQuery</code> in a component deeper down in the tree you need to pass the <code>initialData</code> down to that point</li><li>If you are calling <code>useQuery</code> with the same query in multiple locations, you need to pass <code>initialData</code> to all of them</li><li>There is no way to know at what time the query was fetched on the server, so <code>dataUpdatedAt</code> and determining if the query needs refetching is based on when the page loaded instead</li></ul><h3 id="using-hydration"><a class="header-anchor" href="#using-hydration" aria-hidden="true">#</a> Using Hydration</h3><p>Vu Query supports prefetching multiple queries on the server in Next.js and then <em>dehydrating</em> those queries to the queryClient. This means the server can prerender markup that is immediately available on page load and as soon as JS is available, Vu Query can upgrade or <em>hydrate</em> those queries with the full functionality of the library. This includes refetching those queries on the client if they have become stale since the time they were rendered on the server.</p><p>To support caching queries on the server and set up hydration:</p><ul><li>Create a new <code>QueryClient</code> instance</li><li>Wrap your app component with <code>&lt;QueryClientProvider&gt;</code> and pass it the client instance</li><li>Wrapp your app component with <code>&lt;Hydrate&gt;</code> and pass it the <code>dehydratedState</code> prop from <code>pageProps</code></li></ul><div class="language-js"><pre><code><span class="token comment">// _app.jsx</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> QueryClient<span class="token punctuation">,</span> QueryClientProvider <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vu-query&#39;</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> Hydrate <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vu-query/hydration&#39;</span>\n\n<span class="token keyword">const</span> queryClient <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">MyApp</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> Component<span class="token punctuation">,</span> pageProps <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span>\n    <span class="token operator">&lt;</span>QueryClientProvider client<span class="token operator">=</span><span class="token punctuation">{</span>queryClient<span class="token punctuation">}</span><span class="token operator">&gt;</span>\n      <span class="token operator">&lt;</span>Hydrate state<span class="token operator">=</span><span class="token punctuation">{</span>pageProps<span class="token punctuation">.</span>dehydratedState<span class="token punctuation">}</span><span class="token operator">&gt;</span>\n        <span class="token operator">&lt;</span>Component <span class="token punctuation">{</span><span class="token operator">...</span>pageProps<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>Hydrate<span class="token operator">&gt;</span>\n    <span class="token operator">&lt;</span><span class="token operator">/</span>QueryClientProvider<span class="token operator">&gt;</span>\n  <span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>Now you are ready to prefetch some data in your pages with either <a href="https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation" target="_blank" rel="noopener noreferrer"><code>getStaticProps</code></a> (for SSG) or <a href="https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering" target="_blank" rel="noopener noreferrer"><code>getServerSideProps</code></a> (for SSR). From Vu Query&#39;s perspective, these integrate in the same way, <code>getStaticProps</code> is shown below.</p><ul><li>Create a new <code>QueryClient</code> instance for each page request</li><li>Prefetch the data using the clients <code>prefetchQuery</code> method and wait for it to complete</li><li>Use <code>dehydrate</code> to dehydrate the query cache and pass it to the page via the <code>dehydratedState</code> prop. This is the same prop that the cache will be picked up from in your <code>_app.js</code></li></ul><div class="language-js"><pre><code><span class="token comment">// pages/posts.jsx</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> QueryClient<span class="token punctuation">,</span> useQuery <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vu-query&#39;</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> dehydrate <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vu-query/hydration&#39;</span>\n\n<span class="token keyword">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getStaticProps</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> queryClient <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n  <span class="token keyword">await</span> queryClient<span class="token punctuation">.</span><span class="token function">prefetchQuery</span><span class="token punctuation">(</span><span class="token string">&#39;posts&#39;</span><span class="token punctuation">,</span> getPosts<span class="token punctuation">)</span>\n\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    props<span class="token operator">:</span> <span class="token punctuation">{</span>\n      dehydratedState<span class="token operator">:</span> <span class="token function">dehydrate</span><span class="token punctuation">(</span>queryClient<span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">Posts</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// This useQuery could just as well happen in some deeper child to</span>\n  <span class="token comment">// the &quot;Posts&quot;-page, data will be available immediately either way</span>\n  <span class="token keyword">const</span> <span class="token punctuation">{</span> data <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useQuery</span><span class="token punctuation">(</span><span class="token string">&#39;posts&#39;</span><span class="token punctuation">,</span> getPosts<span class="token punctuation">)</span>\n\n  <span class="token comment">// This query was not prefetched on the server and will not start</span>\n  <span class="token comment">// fetching until on the client, both patterns are fine to mix</span>\n  <span class="token keyword">const</span> <span class="token punctuation">{</span> data<span class="token operator">:</span> otherData <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useQuery</span><span class="token punctuation">(</span><span class="token string">&#39;posts-2&#39;</span><span class="token punctuation">,</span> getPosts<span class="token punctuation">)</span>\n\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>As demonstrated, it&#39;s fine to prefetch some queries and let others fetch on the queryClient. This means you can control what content server renders or not by adding or removing <code>prefetchQuery</code> for a specific query.</p><h2 id="using-other-frameworks-or-custom-ssr-frameworks"><a class="header-anchor" href="#using-other-frameworks-or-custom-ssr-frameworks" aria-hidden="true">#</a> Using Other Frameworks or Custom SSR Frameworks</h2><p>This guide is at-best, a high level overview of how SSR with Vu Query should work. Your mileage may vary since there are many different possible setups for SSR.</p><blockquote><p>If you can, please contribution your findings back to this page for any framework specific guidance!</p></blockquote><h3 id="on-the-server"><a class="header-anchor" href="#on-the-server" aria-hidden="true">#</a> On the Server</h3><ul><li>Create a new <code>QueryClient</code> instance</li><li>Using the client, prefetch any data you need</li><li>Dehydrate the client</li><li>Render your app with the client provider and also <strong>using the dehydrated state. This is extremely important! You must render both server and client using the same dehydrated state to ensure hydration on the client produces the exact same markup as the server.</strong></li><li>Serialize and embed the dehydrated cache to be sent to the client with the HTML</li></ul><blockquote><p>SECURITY NOTE: Serializing data with <code>JSON.stringify</code> can put you at risk for XSS-vulnerabilities, <a href="https://medium.com/node-security/the-most-common-xss-vulnerability-in-react-js-applications-2bdffbcc1fa0" target="_blank" rel="noopener noreferrer">this blog post explains why and how to solve it</a></p></blockquote><div class="language-js"><pre><code><span class="token keyword">import</span> <span class="token punctuation">{</span> QueryClient<span class="token punctuation">,</span> QueryClientProvider <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vu-query&#39;</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> dehydrate<span class="token punctuation">,</span> Hydrate <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vu-query/hydration&#39;</span>\n\n<span class="token keyword">const</span> queryClient <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token keyword">await</span> queryClient<span class="token punctuation">.</span><span class="token function">prefetchQuery</span><span class="token punctuation">(</span><span class="token string">&#39;key&#39;</span><span class="token punctuation">,</span> fn<span class="token punctuation">)</span>\n<span class="token keyword">const</span> dehydratedState <span class="token operator">=</span> <span class="token function">dehydrate</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> html <span class="token operator">=</span> ReactDOM<span class="token punctuation">.</span><span class="token function">renderToString</span><span class="token punctuation">(</span>\n  <span class="token operator">&lt;</span>QueryClientProvider client<span class="token operator">=</span><span class="token punctuation">{</span>queryClient<span class="token punctuation">}</span><span class="token operator">&gt;</span>\n    <span class="token operator">&lt;</span>Hydrate state<span class="token operator">=</span><span class="token punctuation">{</span>dehydratedState<span class="token punctuation">}</span><span class="token operator">&gt;</span>\n      <span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span>\n    <span class="token operator">&lt;</span><span class="token operator">/</span>Hydrate<span class="token operator">&gt;</span>\n  <span class="token operator">&lt;</span><span class="token operator">/</span>QueryClientProvider<span class="token operator">&gt;</span>\n<span class="token punctuation">)</span>\n\nres<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">\n  &lt;html&gt;\n    &lt;body&gt;\n      &lt;div id=&quot;root&quot;&gt;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>html<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&lt;/div&gt;\n      &lt;script&gt;\n        window.__REACT_QUERY_STATE__ = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>dehydratedState<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">;\n      &lt;/script&gt;\n    &lt;/body&gt;\n  &lt;/html&gt;\n  </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>\n</code></pre></div><h3 id="client"><a class="header-anchor" href="#client" aria-hidden="true">#</a> Client</h3><ul><li>Parse the dehydrated cache state that was sent to the client with the HTML</li><li>Create a new <code>QueryClient</code> instance</li><li>Render your app with the client provider and also <strong>using the dehydrated state. This is extremely important! You must render both server and client using the same dehydrated state to ensure hydration on the client produces the exact same markup as the server.</strong></li></ul><div class="language-js"><pre><code><span class="token keyword">import</span> <span class="token punctuation">{</span> QueryClient<span class="token punctuation">,</span> QueryClientProvider <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vu-query&#39;</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> Hydrate <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vu-query/hydration&#39;</span>\n\n<span class="token keyword">const</span> dehydratedState <span class="token operator">=</span> window<span class="token punctuation">.</span>__REACT_QUERY_STATE__\n\n<span class="token keyword">const</span> queryClient <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\nReactDOM<span class="token punctuation">.</span><span class="token function">hydrate</span><span class="token punctuation">(</span>\n  <span class="token operator">&lt;</span>QueryClientProvider client<span class="token operator">=</span><span class="token punctuation">{</span>queryClient<span class="token punctuation">}</span><span class="token operator">&gt;</span>\n    <span class="token operator">&lt;</span>Hydrate state<span class="token operator">=</span><span class="token punctuation">{</span>dehydratedState<span class="token punctuation">}</span><span class="token operator">&gt;</span>\n      <span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span>\n    <span class="token operator">&lt;</span><span class="token operator">/</span>Hydrate<span class="token operator">&gt;</span>\n  <span class="token operator">&lt;</span><span class="token operator">/</span>QueryClientProvider<span class="token operator">&gt;</span><span class="token punctuation">,</span>\n  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;root&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">)</span>\n</code></pre></div><h2 id="tips-tricks-and-caveats"><a class="header-anchor" href="#tips-tricks-and-caveats" aria-hidden="true">#</a> Tips, Tricks and Caveats</h2><h3 id="only-successful-queries-are-included-in-dehydration"><a class="header-anchor" href="#only-successful-queries-are-included-in-dehydration" aria-hidden="true">#</a> Only successful queries are included in dehydration</h3><p>Any query with an error is automatically excluded from dehydration. This means that the default behaviour is to pretend these queries were never loaded on the server, usually showing a loading state instead, and retrying the queries on the queryClient. This happens regardless of error.</p><p>Sometimes this behavior is not desirable, maybe you want to render an error page with a correct status code instead on certain errors or queries. In those cases, use <code>fetchQuery</code> and catch any errors to handle those manually.</p><h3 id="staleness-is-measured-from-when-the-query-was-fetched-on-the-server"><a class="header-anchor" href="#staleness-is-measured-from-when-the-query-was-fetched-on-the-server" aria-hidden="true">#</a> Staleness is measured from when the query was fetched on the server</h3><p>A query is considered stale depending on when it was <code>dataUpdatedAt</code>. A caveat here is that the server needs to have the correct time for this to work properly, but UTC time is used, so timezones do not factor into this.</p><p>Because <code>staleTime</code> defaults to <code>0</code>, queries will be refetched in the background on page load by default. You might want to use a higher <code>staleTime</code> to avoid this double fetching, especially if you don&#39;t cache your markup.</p><p>This refetching of stale queries is a perfect match when caching markup in a CDN! You can set the cache time of the page itself decently high to avoid having to re-render pages on the server, but configure the <code>staleTime</code> of the queries lower to make sure data is refetched in the background as soon as a user visits the page. Maybe you want to cache the pages for a week, but refetch the data automatically on page load if it&#39;s older than a day?</p>',38);t.render=function(a,e,t,p,r,c){return n(),s("div",null,[o])};export default t;export{e as __pageData};
