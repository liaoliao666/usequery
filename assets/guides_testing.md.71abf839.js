import{l as e,f as t,G as r}from"./framework.dc3bd9a4.js";const n='{"title":"Testing","description":"","frontmatter":{"id":"testing","title":"Testing"},"headers":[{"level":2,"title":"Our First Test","slug":"our-first-test"},{"level":2,"title":"Testing Network Calls","slug":"testing-network-calls"},{"level":2,"title":"Testing Load More / Infinite Scroll","slug":"testing-load-more-infinite-scroll"}],"relativePath":"guides/testing.md","lastUpdated":1610472514943}',o={},a=r('<p>Vue Query works by means of hooks - either the ones we offer or custom ones that wrap around them.</p><p>Writing unit tests for these custom hooks can be done by means of the <a href="https://vue-hooks-testing-library.com/" target="_blank" rel="noopener noreferrer">Vue Hooks Testing Library</a> library.</p><p>Install this by running:</p><div class="language-sh"><pre><code>npm install @testing-library/vue-hooks vue-test-renderer --save-dev\n</code></pre></div><p>(The <code>vue-test-renderer</code> library is needed as a peer dependency of <code>@testing-library/vue-hooks</code>, and needs to correspond to the version of Vue that you are using.)</p><h2 id="our-first-test"><a class="header-anchor" href="#our-first-test" aria-hidden="true">#</a> Our First Test</h2><p>Once installed, a simple test can be written. Given the following custom hook:</p><div class="language-"><pre><code>export function useCustomHook() {\n  const { data } = useQuery(&#39;customHook&#39;, () =&gt; &#39;Hello&#39;);\n  return data;\n}\n</code></pre></div><p>We can write a test for this as follows:</p><div class="language-"><pre><code>const queryCache = new QueryCache();\nconst wrapper = ({ children }) =&gt; (\n  &lt;ReactQueryCacheProvider queryCache={queryCache}&gt;\n    {children}\n  &lt;/ReactQueryCacheProvider&gt;\n);\n\nconst { result } = renderHook(() =&gt; useCustomHook(), { wrapper });\n\nexpect(result.current).toEqual(&#39;Hello&#39;);\n</code></pre></div><p>Note that we provide a custom wrapper that builds the <code>QueryCache</code> and <code>ReactQueryCacheProvider</code>. This helps to ensure that our test is completely isolated from any other tests.</p><p>It is possible to write this wrapper only once, but if so we need to ensure that the <code>QueryCache</code> gets cleared before every test, and that tests don&#39;t run in parallel otherwise one test will influence the results of others.</p><h2 id="testing-network-calls"><a class="header-anchor" href="#testing-network-calls" aria-hidden="true">#</a> Testing Network Calls</h2><p>The primary use for Vue Query is to cache network requests, so it&#39;s important that we can test our code is making the correct network requests in the first place.</p><p>There are plenty of ways that these can be tested, but for this example we are going to use <a href="https://www.npmjs.com/package/nock" target="_blank" rel="noopener noreferrer">nock</a>.</p><p>Given the following custom hook:</p><div class="language-"><pre><code>function useFetchData() {\n  return useQuery(&#39;fetchData&#39;, () =&gt; request(&#39;/api/data&#39;));\n}\n</code></pre></div><p>We can write a test for this as follows:</p><div class="language-"><pre><code>const queryCache = new QueryCache();\nconst wrapper = ({ children }) =&gt; (\n  &lt;ReactQueryCacheProvider queryCache={queryCache}&gt;\n    {children}\n  &lt;/ReactQueryCacheProvider&gt;\n);\n\nconst expectation = nock(&#39;http://example.com&#39;)\n  .get(&#39;/api/data&#39;)\n  .reply(200, {\n    answer: 42\n  });\n\nconst { result, waitFor } = renderHook(() =&gt; useFetchData(), { wrapper });\n\nawait waitFor(() =&gt; {\n  return result.current.isSuccess;\n});\n\nexpect(result.current).toEqual({answer: 42});\n</code></pre></div><p>Here we are making use of <code>waitFor</code> and waiting until our the query status indicates that the request has succeeded. This way we know that our hook has finished and should have the correct data.</p><h2 id="testing-load-more-infinite-scroll"><a class="header-anchor" href="#testing-load-more-infinite-scroll" aria-hidden="true">#</a> Testing Load More / Infinite Scroll</h2><p>First we need to mock our API response</p><div class="language-"><pre><code>function generateMockedResponse(page) {\n  return {\n    page: page,\n    items: [...]\n  }\n}\n</code></pre></div><p>Then, our <code>nock</code> configuration needs to differentiate responses based on the page, and we&#39;ll be using <code>uri</code> to do this. <code>uri</code>&#39;s value here will be something like <code>&quot;/?page=1</code> or <code>/?page=2</code></p><div class="language-"><pre><code>const expectation = nock(&#39;http://example.com&#39;)\n  .persist()\n  .query(true)\n  .get(&#39;/api/data&#39;)\n  .reply(200, (uri) =&gt; {\n    const url = new URL(`http://example.com${uri}`);\n    const { page } = Object.fromEntries(url.searchParams);\n    return generateMockedResponse(page);\n  });\n</code></pre></div><p>(Notice the <code>.persist()</code>, because we&#39;ll be calling from this endpoint multiple times)</p><p>Now we can safely run our tests, the trick here is to await both <code>isFetching</code> and then <code>!isFetching</code> after calling <code>fetchMore()</code>:</p><div class="language-"><pre><code>const { result, waitFor } = renderHook(() =&gt; useInfiniteQueryCustomHook(), { wrapper });\n\nawait waitFor(() =&gt; result.current.isSuccess);\n\nexpect(result.current.data).toStrictEqual(generateMockedResponse(1));\n\nresult.current.fetchMore();\n\nawait waitFor(() =&gt; result.current.isFetching);\nawait waitFor(() =&gt; !result.current.isFetching);\n\nexpect(result.current.data).toStrictEqual([\n  ...generateMockedResponse(1),\n  ...generateMockedResponse(2),\n]);\n\nexpectation.done();\n</code></pre></div>',28);o.render=function(r,n,o,s,i,c){return e(),t("div",null,[a])};export default o;export{n as __pageData};
